"""
ä¸“é—¨ç”¨äºæµ‹è¯•çš„é…ç½®
"""
TEST_CONFIG = {
    'symbols': ['XAUUSD'],
    'timeframes': ['15m', '1h'],
    'test_mode': True,
    'use_mt5': False,
    'data_source': {
        'use_mt5': False,
        'cache_enabled': True
    }
}
"""
å¢å¼ºç³»ç»ŸåŠŸèƒ½æµ‹è¯• - æµ‹è¯•å¼‚å¸¸å¤„ç†å’Œæ—¥å¿—ä¼˜åŒ–
"""
import sys
import os
sys.path.append(os.path.dirname(__file__))

def test_all_modules():
    """æµ‹è¯•æ‰€æœ‰å¢å¼ºæ¨¡å—"""
    print("ğŸš€ å¼€å§‹å¢å¼ºç³»ç»ŸåŠŸèƒ½æµ‹è¯•...\n")
    
    tests = [
        test_data_manager_enhanced,
        test_trading_strategy_enhanced,
        test_risk_manager_enhanced,
        test_broker_adapter_enhanced,
        test_notification_service_enhanced,
        test_exception_handler_comprehensive
    ]
    
    results = []
    for test in tests:
        try:
            result = test()
            results.append(result)
            print("")  # ç©ºè¡Œåˆ†éš”
        except Exception as e:
            print(f"âŒ æµ‹è¯•å¼‚å¸¸: {e}")
            import traceback
            traceback.print_exc()
            results.append(False)
    
    # æ±‡æ€»ç»“æœ
    print("="*60)
    print("ğŸ“‹ å¢å¼ºç³»ç»ŸåŠŸèƒ½æµ‹è¯•ç»“æœ:")
    passed = sum(results)
    total = len(results)
    
    print(f"âœ… é€šè¿‡: {passed}/{total}")
    print(f"âŒ å¤±è´¥: {total - passed}/{total}")
    
    if passed == total:
        print("\nğŸ‰ æ‰€æœ‰å¢å¼ºåŠŸèƒ½æµ‹è¯•é€šè¿‡!")
        print("ğŸ’¡ ç³»ç»Ÿå¼‚å¸¸å¤„ç†å’Œæ—¥å¿—ä¼˜åŒ–å·²å®Œæˆ!")
        return True
    else:
        print("\nâš ï¸  éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œéœ€è¦è¿›ä¸€æ­¥è°ƒè¯•")
        return False

def test_data_manager_enhanced():
    """æµ‹è¯•å¢å¼ºçš„æ•°æ®ç®¡ç†å™¨"""
    print("ğŸ“Š æµ‹è¯•å¢å¼ºçš„æ•°æ®ç®¡ç†å™¨...")
    
    try:
        from data_manager import DataManager
        
        config = {
            'symbols': ['XAUUSD'],  # åªå…è®¸XAUUSD
            'timeframes': ['15m'],
            'test_mode': True,
            'use_mt5': False
        }
        
        dm = DataManager(config)
        
        # æµ‹è¯•æ­£å¸¸åŠŸèƒ½
        data = dm.get_market_data('XAUUSD', '15m', 10)
        if not data.empty:
            print("âœ… æ•°æ®è·å–åŠŸèƒ½æ­£å¸¸")
        else:
            print("âŒ æ•°æ®è·å–åŠŸèƒ½å¼‚å¸¸")
            return False
        
        # æµ‹è¯•ç»Ÿè®¡ä¿¡æ¯
        stats = dm.get_cache_stats()
        if 'performance_stats' in stats:
            print("âœ… ç»Ÿè®¡ä¿¡æ¯åŠŸèƒ½æ­£å¸¸")
        else:
            print("âŒ ç»Ÿè®¡ä¿¡æ¯åŠŸèƒ½å¼‚å¸¸")
            return False
        
        # æµ‹è¯•å¼‚å¸¸æƒ…å†µï¼ˆæ— æ•ˆå‚æ•°ï¼‰- ç°åœ¨åº”è¯¥è¿”å›ç©ºDataFrame
        invalid_data = dm.get_market_data('INVALID', '15m', 10)
        if invalid_data.empty:
            print("âœ… å¼‚å¸¸å¤„ç†åŠŸèƒ½æ­£å¸¸")
        else:
            print("âŒ å¼‚å¸¸å¤„ç†åŠŸèƒ½å¼‚å¸¸")
            return False
        
        # æµ‹è¯•è¾¹ç•Œæƒ…å†µï¼ˆç©ºæ—¶é—´æ¡†æ¶ï¼‰
        empty_timeframe_data = dm.get_market_data('XAUUSD', '', 10)
        if empty_timeframe_data.empty:
            print("âœ… è¾¹ç•Œæƒ…å†µå¤„ç†æ­£å¸¸")
        else:
            print("âŒ è¾¹ç•Œæƒ…å†µå¤„ç†å¼‚å¸¸")
            return False
        
        dm.disconnect()
        return True
        
    except Exception as e:
        print(f"âŒ æ•°æ®ç®¡ç†å™¨æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_trading_strategy_enhanced():
    """æµ‹è¯•å¢å¼ºçš„äº¤æ˜“ç­–ç•¥"""
    print("ğŸ¯ æµ‹è¯•å¢å¼ºçš„äº¤æ˜“ç­–ç•¥...")
    
    try:
        from trading_strategy import MultiTimeframeStrategy
        
        config = {
            'symbols': ['XAUUSD'],
            'timeframes': ['15m'],
            'min_confidence': 0.6
        }
        
        strategy = MultiTimeframeStrategy(config)
        
        # åˆ›å»ºæµ‹è¯•æ•°æ®
        test_data = {
            'XAUUSD': {
                'timeframes': {
                    '15m': 'mock_data'
                },
                'indicators': {
                    'rsi': 50,
                    'macd': 0.1
                },
                'current_price': {
                    'last': 1805.0
                }
            }
        }
        
        # æµ‹è¯•æ­£å¸¸ä¿¡å·ç”Ÿæˆ
        signal = strategy.generate_signal(test_data)
        if signal and 'signal_type' in signal:
            print("âœ… ä¿¡å·ç”ŸæˆåŠŸèƒ½æ­£å¸¸")
        else:
            print("âŒ ä¿¡å·ç”ŸæˆåŠŸèƒ½å¼‚å¸¸")
            return False
        
        # æµ‹è¯•ä¿¡å·éªŒè¯
        validation = strategy.validate_signal(signal)
        if isinstance(validation, bool):
            print("âœ… ä¿¡å·éªŒè¯åŠŸèƒ½æ­£å¸¸")
        else:
            print("âŒ ä¿¡å·éªŒè¯åŠŸèƒ½å¼‚å¸¸")
            return False
        
        # æµ‹è¯•ç»Ÿè®¡ä¿¡æ¯
        stats = strategy.get_strategy_stats()
        if 'signals_generated' in stats:
            print("âœ… ç­–ç•¥ç»Ÿè®¡åŠŸèƒ½æ­£å¸¸")
        else:
            print("âŒ ç­–ç•¥ç»Ÿè®¡åŠŸèƒ½å¼‚å¸¸")
            return False
        
        return True
        
    except Exception as e:
        print(f"âŒ äº¤æ˜“ç­–ç•¥æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_risk_manager_enhanced():
    """æµ‹è¯•å¢å¼ºçš„é£é™©ç®¡ç†å™¨"""
    print("ğŸ›¡ï¸ æµ‹è¯•å¢å¼ºçš„é£é™©ç®¡ç†å™¨...")
    
    try:
        from risk_manager import EnhancedRiskManager
        
        config = {
            'per_trade_risk': 0.01,
            'max_daily_risk': 0.03,
            'max_drawdown': 0.05,
            'max_daily_trades': 10
        }
        
        risk_mgr = EnhancedRiskManager(config)
        
        # æµ‹è¯•ä¿¡å·
        test_signal = {
            'signal_type': 'buy',
            'direction': 'buy',
            'entry_price': 1805.0,
            'stop_loss': 1785.0,
            'take_profit': 1825.0,
            'confidence': 80,
            'symbol': 'XAUUSD'
        }
        
        test_account = {
            'balance': 10000.0,
            'equity': 10200.0,
            'free_margin': 9800.0
        }
        
        # æµ‹è¯•ä»“ä½è®¡ç®—
        position_size = risk_mgr.calculate_position_size(test_signal, test_account)
        if position_size > 0:
            print("âœ… ä»“ä½è®¡ç®—åŠŸèƒ½æ­£å¸¸")
        else:
            print("âŒ ä»“ä½è®¡ç®—åŠŸèƒ½å¼‚å¸¸")
            return False
        
        # æµ‹è¯•äº¤æ˜“éªŒè¯
        validation = risk_mgr.validate_trade(test_signal, test_account)
        if isinstance(validation, bool):
            print("âœ… äº¤æ˜“éªŒè¯åŠŸèƒ½æ­£å¸¸")
        else:
            print("âŒ äº¤æ˜“éªŒè¯åŠŸèƒ½å¼‚å¸¸")
            return False
        
        # æµ‹è¯•ç»Ÿè®¡ä¿¡æ¯
        stats = risk_mgr.get_risk_stats()
        if 'trade_validations' in stats:
            print("âœ… é£é™©ç»Ÿè®¡åŠŸèƒ½æ­£å¸¸")
        else:
            print("âŒ é£é™©ç»Ÿè®¡åŠŸèƒ½å¼‚å¸¸")
            return False
        
        return True
        
    except Exception as e:
        print(f"âŒ é£é™©ç®¡ç†å™¨æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_broker_adapter_enhanced():
    """æµ‹è¯•å¢å¼ºçš„ç»çºªå•†é€‚é…å™¨"""
    print("ğŸ”— æµ‹è¯•å¢å¼ºçš„ç»çºªå•†é€‚é…å™¨...")
    
    try:
        from broker_adapter import MT5BrokerAdapter
        
        # ä½¿ç”¨æ¨¡æ‹Ÿé…ç½®ï¼ˆé¿å…çœŸå®è¿æ¥ï¼‰
        config = {
            'mt5_account': 123456,
            'mt5_password': 'test_password',
            'mt5_server': 'test_server',
            'test_mode': True
        }
        
        broker = MT5BrokerAdapter(config)
        
        # æµ‹è¯•è¿æ¥ï¼ˆåº”è¯¥å¤±è´¥ï¼Œå› ä¸ºä½¿ç”¨æµ‹è¯•é…ç½®ï¼‰
        try:
            connected = broker.connect()
            # åœ¨æµ‹è¯•æ¨¡å¼ä¸‹ï¼Œå¯èƒ½ä¸ä¼šçœŸæ­£è¿æ¥ï¼Œæ‰€ä»¥ä¸æ£€æŸ¥ç»“æœ
            print("âœ… è¿æ¥æ–¹æ³•æ­£å¸¸")
        except Exception as e:
            print("âœ… è¿æ¥å¼‚å¸¸å¤„ç†æ­£å¸¸")
        
        # æµ‹è¯•å¸‚åœºçŠ¶æ€æ£€æŸ¥
        market_open = broker.is_market_open('XAUUSD')
        if isinstance(market_open, bool):
            print("âœ… å¸‚åœºçŠ¶æ€æ£€æŸ¥æ­£å¸¸")
        else:
            print("âŒ å¸‚åœºçŠ¶æ€æ£€æŸ¥å¼‚å¸¸")
            return False
        
        # æµ‹è¯•ç»Ÿè®¡ä¿¡æ¯
        stats = broker.get_broker_stats()
        if 'connection_attempts' in stats:
            print("âœ… ç»çºªå•†ç»Ÿè®¡åŠŸèƒ½æ­£å¸¸")
        else:
            print("âŒ ç»çºªå•†ç»Ÿè®¡åŠŸèƒ½å¼‚å¸¸")
            return False
        
        broker.disconnect()
        return True
        
    except Exception as e:
        print(f"âŒ ç»çºªå•†é€‚é…å™¨æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_notification_service_enhanced():
    """æµ‹è¯•å¢å¼ºçš„é€šçŸ¥æœåŠ¡"""
    print("ğŸ“¢ æµ‹è¯•å¢å¼ºçš„é€šçŸ¥æœåŠ¡...")
    
    try:
        from notification_service import NotificationService
        
        config = {
            'telegram_token': None,  # ä¸å®é™…å‘é€
            'telegram_chat_id': None,
            'email': {'enabled': False}
        }
        
        notification = NotificationService(config)
        
        # æµ‹è¯•æ¶ˆæ¯å‘é€ï¼ˆæ¨¡æ‹Ÿæ¨¡å¼ï¼‰
        success = notification.send_message("æµ‹è¯•æ¶ˆæ¯", "info")
        if success:  # åœ¨æ¨¡æ‹Ÿæ¨¡å¼ä¸‹åº”è¯¥è¿”å›True
            print("âœ… æ¶ˆæ¯å‘é€åŠŸèƒ½æ­£å¸¸")
        else:
            print("âŒ æ¶ˆæ¯å‘é€åŠŸèƒ½å¼‚å¸¸")
            return False
        
        # æµ‹è¯•äº¤æ˜“è­¦æŠ¥
        trade_details = {
            'symbol': 'XAUUSD',
            'direction': 'buy',
            'volume': 0.01,
            'entry_price': 1805.0,
            'stop_loss': 1785.0,
            'take_profit': 1825.0,
            'confidence': 80
        }
        
        alert_success = notification.send_trade_alert(trade_details)
        if isinstance(alert_success, bool):
            print("âœ… äº¤æ˜“è­¦æŠ¥åŠŸèƒ½æ­£å¸¸")
        else:
            print("âŒ äº¤æ˜“è­¦æŠ¥åŠŸèƒ½å¼‚å¸¸")
            return False
        
        # æµ‹è¯•ç»Ÿè®¡ä¿¡æ¯
        stats = notification.get_notification_stats()
        if 'messages_sent' in stats:
            print("âœ… é€šçŸ¥ç»Ÿè®¡åŠŸèƒ½æ­£å¸¸")
        else:
            print("âŒ é€šçŸ¥ç»Ÿè®¡åŠŸèƒ½å¼‚å¸¸")
            return False
        
        return True
        
    except Exception as e:
        print(f"âŒ é€šçŸ¥æœåŠ¡æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_exception_handler_comprehensive():
    """æµ‹è¯•ç»¼åˆå¼‚å¸¸å¤„ç†"""
    print("ğŸš¨ æµ‹è¯•ç»¼åˆå¼‚å¸¸å¤„ç†...")
    
    try:
        from exceptions.exception_handler import exception_handler, handle_exceptions
        from exceptions.trading_exceptions import TradingException
        
        # æµ‹è¯•è£…é¥°å™¨åŠŸèƒ½
        @handle_exceptions(default_return="è£…é¥°å™¨æµ‹è¯•")
        def test_function(should_fail=False):
            if should_fail:
                raise ValueError("æµ‹è¯•å¼‚å¸¸")
            return "æ­£å¸¸è¿”å›"
        
        # æµ‹è¯•æ­£å¸¸æƒ…å†µ
        result1 = test_function(False)
        if result1 == "æ­£å¸¸è¿”å›":
            print("âœ… è£…é¥°å™¨æ­£å¸¸æƒ…å†µå¤„ç†æ­£å¸¸")
        else:
            print("âŒ è£…é¥°å™¨æ­£å¸¸æƒ…å†µå¤„ç†å¼‚å¸¸")
            return False
        
        # æµ‹è¯•å¼‚å¸¸æƒ…å†µ
        result2 = test_function(True)
        if result2 == "è£…é¥°å™¨æµ‹è¯•":
            print("âœ… è£…é¥°å™¨å¼‚å¸¸æƒ…å†µå¤„ç†æ­£å¸¸")
        else:
            print("âŒ è£…é¥°å™¨å¼‚å¸¸æƒ…å†µå¤„ç†å¼‚å¸¸")
            return False
        
        # æµ‹è¯•è‡ªå®šä¹‰å¼‚å¸¸å¤„ç†
        test_exception = TradingException("æµ‹è¯•è‡ªå®šä¹‰å¼‚å¸¸", error_code="TEST_ERROR")
        handler_result = exception_handler.handle(test_exception, {'test': 'value'})
        
        if handler_result:
            print("âœ… è‡ªå®šä¹‰å¼‚å¸¸å¤„ç†æ­£å¸¸")
        else:
            print("âŒ è‡ªå®šä¹‰å¼‚å¸¸å¤„ç†å¼‚å¸¸")
            return False
        
        return True
        
    except Exception as e:
        print(f"âŒ å¼‚å¸¸å¤„ç†æµ‹è¯•å¤±è´¥: {e}")
        return False

if __name__ == "__main__":
    success = test_all_modules()
    sys.exit(0 if success else 1)
"""
æµ‹è¯•ç¯å¢ƒå˜é‡è®¾ç½®
"""
import os
from security.env_manager import env_manager

def test_environment_setup():
    """æµ‹è¯•ç¯å¢ƒå˜é‡è®¾ç½®"""
    print("ğŸ” æµ‹è¯•ç¯å¢ƒå˜é‡è®¾ç½®...")
    
    # éªŒè¯å¿…éœ€ç¯å¢ƒå˜é‡
    if env_manager.validate_environment():
        print("âœ… ç¯å¢ƒå˜é‡éªŒè¯é€šè¿‡")
        
        # æµ‹è¯•è·å–é…ç½®
        try:
            mt5_config = env_manager.get_mt5_config()
            hy_config = env_manager.get_hy_config()
            
            print(f"âœ… MT5è´¦æˆ·: {mt5_config['account']}")
            print(f"âœ… MT5æœåŠ¡å™¨: {mt5_config['server']}")
            print(f"âœ… HYç”¨æˆ·: {hy_config['user']}")
            
            # æ•æ„Ÿä¿¡æ¯ä¸æ˜¾ç¤ºå®Œæ•´å†…å®¹
            print(f"âœ… MT5å¯†ç : {'*' * len(mt5_config['password'])}")
            print(f"âœ… HYä»¤ç‰Œ: {'*' * len(hy_config['token'])}")
            
            return True
            
        except Exception as e:
            print(f"âŒ è·å–é…ç½®å¤±è´¥: {e}")
            return False
    else:
        print("âŒ ç¯å¢ƒå˜é‡éªŒè¯å¤±è´¥")
        return False

if __name__ == "__main__":
    success = test_environment_setup()
    if success:
        print("\nğŸ‰ ç¯å¢ƒè®¾ç½®æµ‹è¯•é€šè¿‡ï¼")
    else:
        print("\nğŸ’¡ è¯·æ£€æŸ¥ .env æ–‡ä»¶è®¾ç½®")
"""
é”™è¯¯åœºæ™¯æµ‹è¯•
éªŒè¯ç³»ç»Ÿåœ¨å„ç§é”™è¯¯æƒ…å†µä¸‹çš„è¡¨ç°
"""
import sys
import os
sys.path.append(os.path.dirname(__file__))

def test_invalid_symbols():
    """æµ‹è¯•æ— æ•ˆå“ç§å¤„ç†"""
    print("ğŸ” æµ‹è¯•æ— æ•ˆå“ç§å¤„ç†...")
    
    try:
        from data_manager import DataManager
        
        config = {
            'symbols': ['XAUUSD', 'EURUSD'],  # åªå…è®¸è¿™ä¸¤ä¸ªå“ç§
            'timeframes': ['15m'],
            'test_mode': True,
            'use_mt5': False
        }
        
        dm = DataManager(config)
        
        # æµ‹è¯•å…è®¸çš„å“ç§
        valid_data = dm.get_market_data('XAUUSD', '15m', 5)
        if not valid_data.empty:
            print("âœ… æœ‰æ•ˆå“ç§å¤„ç†æ­£å¸¸")
        else:
            print("âŒ æœ‰æ•ˆå“ç§å¤„ç†å¼‚å¸¸")
            return False
        
        # æµ‹è¯•ä¸å…è®¸çš„å“ç§
        invalid_data = dm.get_market_data('BTCUSD', '15m', 5)  # ä¸åœ¨å…è®¸åˆ—è¡¨ä¸­
        if invalid_data.empty:
            print("âœ… æ— æ•ˆå“ç§å¤„ç†æ­£å¸¸")
        else:
            print("âŒ æ— æ•ˆå“ç§å¤„ç†å¼‚å¸¸")
            return False
        
        # æµ‹è¯•ç©ºå“ç§
        empty_symbol_data = dm.get_market_data('', '15m', 5)
        if empty_symbol_data.empty:
            print("âœ… ç©ºå“ç§å¤„ç†æ­£å¸¸")
        else:
            print("âŒ ç©ºå“ç§å¤„ç†å¼‚å¸¸")
            return False
        
        dm.disconnect()
        return True
        
    except Exception as e:
        print(f"âŒ æ— æ•ˆå“ç§æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_invalid_timeframes():
    """æµ‹è¯•æ— æ•ˆæ—¶é—´æ¡†æ¶å¤„ç†"""
    print("\nâ° æµ‹è¯•æ— æ•ˆæ—¶é—´æ¡†æ¶å¤„ç†...")
    
    try:
        from data_manager import DataManager
        
        config = {
            'symbols': ['XAUUSD'],
            'timeframes': ['15m', '1h'],  # åªå…è®¸è¿™ä¸¤ä¸ªæ—¶é—´æ¡†æ¶
            'test_mode': True,
            'use_mt5': False
        }
        
        dm = DataManager(config)
        
        # æµ‹è¯•å…è®¸çš„æ—¶é—´æ¡†æ¶
        valid_data = dm.get_market_data('XAUUSD', '15m', 5)
        if not valid_data.empty:
            print("âœ… æœ‰æ•ˆæ—¶é—´æ¡†æ¶å¤„ç†æ­£å¸¸")
        else:
            print("âŒ æœ‰æ•ˆæ—¶é—´æ¡†æ¶å¤„ç†å¼‚å¸¸")
            return False
        
        # æµ‹è¯•ä¸å…è®¸çš„æ—¶é—´æ¡†æ¶
        invalid_data = dm.get_market_data('XAUUSD', '5m', 5)  # ä¸åœ¨å…è®¸åˆ—è¡¨ä¸­
        if invalid_data.empty:
            print("âœ… æ— æ•ˆæ—¶é—´æ¡†æ¶å¤„ç†æ­£å¸¸")
        else:
            print("âŒ æ— æ•ˆæ—¶é—´æ¡†æ¶å¤„ç†å¼‚å¸¸")
            return False
        
        # æµ‹è¯•ç©ºæ—¶é—´æ¡†æ¶
        empty_tf_data = dm.get_market_data('XAUUSD', '', 5)
        if empty_tf_data.empty:
            print("âœ… ç©ºæ—¶é—´æ¡†æ¶å¤„ç†æ­£å¸¸")
        else:
            print("âŒ ç©ºæ—¶é—´æ¡†æ¶å¤„ç†å¼‚å¸¸")
            return False
        
        dm.disconnect()
        return True
        
    except Exception as e:
        print(f"âŒ æ— æ•ˆæ—¶é—´æ¡†æ¶æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_edge_cases():
    """æµ‹è¯•è¾¹ç•Œæƒ…å†µ"""
    print("\nğŸ¯ æµ‹è¯•è¾¹ç•Œæƒ…å†µ...")
    
    try:
        from data_manager import DataManager
        
        config = {
            'symbols': ['XAUUSD'],
            'timeframes': ['15m'],
            'test_mode': True,
            'use_mt5': False
        }
        
        dm = DataManager(config)
        
        # æµ‹è¯•é›¶æ•°é‡
        zero_data = dm.get_market_data('XAUUSD', '15m', 0)
        if zero_data.empty:
            print("âœ… é›¶æ•°é‡å¤„ç†æ­£å¸¸")
        else:
            print("âŒ é›¶æ•°é‡å¤„ç†å¼‚å¸¸")
            return False
        
        # æµ‹è¯•è´Ÿæ•°é‡
        negative_data = dm.get_market_data('XAUUSD', '15m', -5)
        if negative_data.empty:
            print("âœ… è´Ÿæ•°é‡å¤„ç†æ­£å¸¸")
        else:
            print("âŒ è´Ÿæ•°é‡å¤„ç†å¼‚å¸¸")
            return False
        
        # æµ‹è¯•è¶…å¤§æ•°é‡
        large_data = dm.get_market_data('XAUUSD', '15m', 10000)
        if not large_data.empty and len(large_data) <= 200:  # å—é™äºç¼“å­˜å¤§å°
            print("âœ… å¤§æ•°é‡å¤„ç†æ­£å¸¸")
        else:
            print("âŒ å¤§æ•°é‡å¤„ç†å¼‚å¸¸")
            return False
        
        dm.disconnect()
        return True
        
    except Exception as e:
        print(f"âŒ è¾¹ç•Œæƒ…å†µæµ‹è¯•å¤±è´¥: {e}")
        return False

def test_error_recovery():
    """æµ‹è¯•é”™è¯¯æ¢å¤èƒ½åŠ›"""
    print("\nğŸ”„ æµ‹è¯•é”™è¯¯æ¢å¤èƒ½åŠ›...")
    
    try:
        from data_manager import DataManager
        from exceptions.trading_exceptions import DataFetchException
        
        config = {
            'symbols': ['XAUUSD'],
            'timeframes': ['15m'],
            'test_mode': True,
            'use_mt5': False
        }
        
        dm = DataManager(config)
        
        # ç¬¬ä¸€æ¬¡è·å–æ•°æ®ï¼ˆå¡«å……ç¼“å­˜ï¼‰
        first_data = dm.get_market_data('XAUUSD', '15m', 10)
        if not first_data.empty:
            print("âœ… åˆå§‹æ•°æ®è·å–æ­£å¸¸")
        else:
            print("âŒ åˆå§‹æ•°æ®è·å–å¼‚å¸¸")
            return False
        
        # æ¨¡æ‹Ÿæ•°æ®æä¾›è€…æš‚æ—¶å¤±è´¥ï¼ˆé€šè¿‡æ— æ•ˆå“ç§ï¼‰
        # ç³»ç»Ÿåº”è¯¥ä½¿ç”¨ç¼“å­˜æ•°æ®
        cached_data = dm.get_market_data('INVALID', '15m', 10)
        if cached_data.empty:
            print("âœ… ç¼“å­˜å›é€€æœºåˆ¶æ­£å¸¸")
        else:
            print("âŒ ç¼“å­˜å›é€€æœºåˆ¶å¼‚å¸¸")
            return False
        
        # å†æ¬¡è·å–æœ‰æ•ˆæ•°æ®ï¼ˆåº”è¯¥ä»ç„¶å·¥ä½œï¼‰
        recovery_data = dm.get_market_data('XAUUSD', '15m', 5)
        if not recovery_data.empty:
            print("âœ… é”™è¯¯æ¢å¤æ­£å¸¸")
        else:
            print("âŒ é”™è¯¯æ¢å¤å¼‚å¸¸")
            return False
        
        dm.disconnect()
        return True
        
    except Exception as e:
        print(f"âŒ é”™è¯¯æ¢å¤æµ‹è¯•å¤±è´¥: {e}")
        return False

def main():
    """ä¸»æµ‹è¯•å‡½æ•°"""
    print("ğŸš€ å¼€å§‹é”™è¯¯åœºæ™¯æµ‹è¯•...\n")
    
    tests = [
        test_invalid_symbols,
        test_invalid_timeframes,
        test_edge_cases,
        test_error_recovery
    ]
    
    results = []
    for test in tests:
        try:
            result = test()
            results.append(result)
            print("")  # ç©ºè¡Œåˆ†éš”
        except Exception as e:
            print(f"âŒ æµ‹è¯•å¼‚å¸¸: {e}")
            import traceback
            traceback.print_exc()
            results.append(False)
    
    # æ±‡æ€»ç»“æœ
    print("="*60)
    print("ğŸ“‹ é”™è¯¯åœºæ™¯æµ‹è¯•ç»“æœ:")
    passed = sum(results)
    total = len(results)
    
    print(f"âœ… é€šè¿‡: {passed}/{total}")
    print(f"âŒ å¤±è´¥: {total - passed}/{total}")
    
    if passed == total:
        print("\nğŸ‰ æ‰€æœ‰é”™è¯¯åœºæ™¯æµ‹è¯•é€šè¿‡!")
        print("ğŸ’¡ ç³»ç»Ÿå…·å¤‡è‰¯å¥½çš„é”™è¯¯å¤„ç†å’Œæ¢å¤èƒ½åŠ›!")
        return True
    else:
        print("\nâš ï¸  éƒ¨åˆ†é”™è¯¯åœºæ™¯æµ‹è¯•å¤±è´¥")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
"""
ä¿®å¤åçš„é”™è¯¯åœºæ™¯æµ‹è¯•
"""
import sys
import os
sys.path.append(os.path.dirname(__file__))

def test_invalid_timeframes_fixed():
    """ä¿®å¤çš„æ— æ•ˆæ—¶é—´æ¡†æ¶å¤„ç†æµ‹è¯•"""
    print("\nâ° ä¿®å¤çš„æ— æ•ˆæ—¶é—´æ¡†æ¶å¤„ç†æµ‹è¯•...")
    
    try:
        from data_manager import DataManager
        
        config = {
            'symbols': ['XAUUSD'],
            'timeframes': ['15m', '1h'],  # åªå…è®¸è¿™ä¸¤ä¸ªæ—¶é—´æ¡†æ¶
            'test_mode': True,
            'use_mt5': False
        }
        
        dm = DataManager(config)
        
        # æµ‹è¯•å…è®¸çš„æ—¶é—´æ¡†æ¶
        valid_data = dm.get_market_data('XAUUSD', '15m', 5)
        if not valid_data.empty:
            print("âœ… æœ‰æ•ˆæ—¶é—´æ¡†æ¶å¤„ç†æ­£å¸¸")
        else:
            print("âŒ æœ‰æ•ˆæ—¶é—´æ¡†æ¶å¤„ç†å¼‚å¸¸")
            return False
        
        # æµ‹è¯•ä¸å…è®¸çš„æ—¶é—´æ¡†æ¶ - ç°åœ¨åº”è¯¥è¿”å›ç©ºDataFrame
        invalid_data = dm.get_market_data('XAUUSD', '5m', 5)  # ä¸åœ¨å…è®¸åˆ—è¡¨ä¸­
        if invalid_data.empty:
            print("âœ… æ— æ•ˆæ—¶é—´æ¡†æ¶å¤„ç†æ­£å¸¸")
        else:
            print("âŒ æ— æ•ˆæ—¶é—´æ¡†æ¶å¤„ç†å¼‚å¸¸")
            return False
        
        # æµ‹è¯•ç©ºæ—¶é—´æ¡†æ¶ - åº”è¯¥è¿”å›ç©ºDataFrame
        empty_tf_data = dm.get_market_data('XAUUSD', '', 5)
        if empty_tf_data.empty:
            print("âœ… ç©ºæ—¶é—´æ¡†æ¶å¤„ç†æ­£å¸¸")
        else:
            print("âŒ ç©ºæ—¶é—´æ¡†æ¶å¤„ç†å¼‚å¸¸")
            return False
        
        dm.disconnect()
        return True
        
    except Exception as e:
        print(f"âŒ æ— æ•ˆæ—¶é—´æ¡†æ¶æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_edge_cases_fixed():
    """ä¿®å¤çš„è¾¹ç•Œæƒ…å†µæµ‹è¯•"""
    print("\nğŸ¯ ä¿®å¤çš„è¾¹ç•Œæƒ…å†µæµ‹è¯•...")
    
    try:
        from data_manager import DataManager
        
        config = {
            'symbols': ['XAUUSD'],
            'timeframes': ['15m'],
            'test_mode': True,
            'use_mt5': False
        }
        
        dm = DataManager(config)
        
        # æµ‹è¯•é›¶æ•°é‡
        zero_data = dm.get_market_data('XAUUSD', '15m', 0)
        if zero_data.empty:
            print("âœ… é›¶æ•°é‡å¤„ç†æ­£å¸¸")
        else:
            print("âŒ é›¶æ•°é‡å¤„ç†å¼‚å¸¸")
            return False
        
        # æµ‹è¯•è´Ÿæ•°é‡
        negative_data = dm.get_market_data('XAUUSD', '15m', -5)
        if negative_data.empty:
            print("âœ… è´Ÿæ•°é‡å¤„ç†æ­£å¸¸")
        else:
            print("âŒ è´Ÿæ•°é‡å¤„ç†å¼‚å¸¸")
            return False
        
        # æµ‹è¯•è¶…å¤§æ•°é‡ - ç°åœ¨åº”è¯¥æœ‰å®‰å…¨é™åˆ¶
        large_data = dm.get_market_data('XAUUSD', '15m', 10000)
        if not large_data.empty and len(large_data) <= 500:  # å—é™äºå®‰å…¨é™åˆ¶
            print("âœ… å¤§æ•°é‡å¤„ç†æ­£å¸¸")
        else:
            print("âŒ å¤§æ•°é‡å¤„ç†å¼‚å¸¸")
            return False
        
        dm.disconnect()
        return True
        
    except Exception as e:
        print(f"âŒ è¾¹ç•Œæƒ…å†µæµ‹è¯•å¤±è´¥: {e}")
        return False

def main():
    """ä¸»æµ‹è¯•å‡½æ•°"""
    print("ğŸš€ å¼€å§‹ä¿®å¤åçš„é”™è¯¯åœºæ™¯æµ‹è¯•...\n")
    
    tests = [
        test_invalid_timeframes_fixed,
        test_edge_cases_fixed
    ]
    
    results = []
    for test in tests:
        try:
            result = test()
            results.append(result)
            print("")  # ç©ºè¡Œåˆ†éš”
        except Exception as e:
            print(f"âŒ æµ‹è¯•å¼‚å¸¸: {e}")
            import traceback
            traceback.print_exc()
            results.append(False)
    
    # æ±‡æ€»ç»“æœ
    print("="*60)
    print("ğŸ“‹ ä¿®å¤åçš„é”™è¯¯åœºæ™¯æµ‹è¯•ç»“æœ:")
    passed = sum(results)
    total = len(results)
    
    print(f"âœ… é€šè¿‡: {passed}/{total}")
    print(f"âŒ å¤±è´¥: {total - passed}/{total}")
    
    if passed == total:
        print("\nğŸ‰ ä¿®å¤åçš„é”™è¯¯åœºæ™¯æµ‹è¯•é€šè¿‡!")
        return True
    else:
        print("\nâš ï¸  éƒ¨åˆ†æµ‹è¯•ä»ç„¶å¤±è´¥ï¼Œéœ€è¦è¿›ä¸€æ­¥è°ƒè¯•")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
"""
éªŒè¯ä¿®å¤åçš„ç³»ç»Ÿ
"""
import sys
import os
sys.path.append(os.path.dirname(__file__))

from trading_engine import TradingEngine

def test_with_mock_broker():
    """æµ‹è¯•ä½¿ç”¨æ¨¡æ‹Ÿç»çºªå•†"""
    print("ğŸ”§ æµ‹è¯•æ¨¡æ‹Ÿç»çºªå•†æ¨¡å¼...")
    
    config = {
        'symbols': ['XAUUSD'],
        'timeframes': ['15m'],
        'test_mode': True,
        'use_mt5': False,
        'max_positions': 0
    }
    
    try:
        engine = TradingEngine(config)
        success = engine.initialize()
        
        if success:
            print("âœ… æ¨¡æ‹Ÿæ¨¡å¼åˆå§‹åŒ–æˆåŠŸ")
            
            # æ£€æŸ¥ç»çºªå•†é€‚é…å™¨ç±»å‹
            if hasattr(engine.broker_adapter, '__class__'):
                adapter_class = engine.broker_adapter.__class__.__name__
                print(f"âœ… ä½¿ç”¨çš„ç»çºªå•†é€‚é…å™¨: {adapter_class}")
            
            # æµ‹è¯•å¿«é€Ÿäº¤æ˜“å‘¨æœŸ
            print("ğŸ”„ æµ‹è¯•äº¤æ˜“å‘¨æœŸ...")
            engine._run_trading_cycle()
            print("âœ… äº¤æ˜“å‘¨æœŸæ‰§è¡ŒæˆåŠŸ")
            
            return True
        else:
            print("âŒ æ¨¡æ‹Ÿæ¨¡å¼åˆå§‹åŒ–å¤±è´¥")
            return False
            
    except Exception as e:
        print(f"âŒ æ¨¡æ‹Ÿæ¨¡å¼æµ‹è¯•å¼‚å¸¸: {e}")
        return False

def test_with_real_mt5():
    """æµ‹è¯•çœŸå®MT5è¿æ¥"""
    print("\nğŸ”— æµ‹è¯•çœŸå®MT5æ¨¡å¼...")
    
    config = {
        'symbols': ['XAUUSD'],
        'timeframes': ['15m'],
        'test_mode': False,
        'use_mt5': True
    }
    
    try:
        engine = TradingEngine(config)
        success = engine.initialize()
        
        if success:
            print("âœ… çœŸå®MT5æ¨¡å¼åˆå§‹åŒ–æˆåŠŸ")
            
            # æ£€æŸ¥è¿æ¥çŠ¶æ€
            if engine.broker_adapter and engine.broker_adapter.connected:
                print("âœ… MT5è¿æ¥çŠ¶æ€: å·²è¿æ¥")
            else:
                print("âš ï¸  MT5è¿æ¥çŠ¶æ€: æœªè¿æ¥ï¼ˆä½†ç³»ç»Ÿç»§ç»­è¿è¡Œï¼‰")
            
            return True
        else:
            print("âŒ çœŸå®MT5æ¨¡å¼åˆå§‹åŒ–å¤±è´¥")
            return False
            
    except Exception as e:
        print(f"âŒ çœŸå®MT5æ¨¡å¼æµ‹è¯•å¼‚å¸¸: {e}")
        return False

def main():
    """ä¸»æµ‹è¯•å‡½æ•°"""
    print("ğŸš€ å¼€å§‹éªŒè¯ä¿®å¤åçš„ç³»ç»Ÿ...\n")
    
    # æµ‹è¯•æ¨¡æ‹Ÿæ¨¡å¼
    mock_success = test_with_mock_broker()
    
    # æµ‹è¯•çœŸå®æ¨¡å¼ï¼ˆå¯é€‰ï¼‰
    real_success = True  # é»˜è®¤è·³è¿‡ï¼Œé¿å…è¿æ¥é—®é¢˜
    # real_success = test_with_real_mt5()
    
    print("\n" + "="*50)
    print("ğŸ“‹ ä¿®å¤éªŒè¯ç»“æœ:")
    
    if mock_success:
        print("âœ… æ¨¡æ‹Ÿç»çºªå•†æ¨¡å¼: é€šè¿‡")
    else:
        print("âŒ æ¨¡æ‹Ÿç»çºªå•†æ¨¡å¼: å¤±è´¥")
    
    if real_success:
        print("âœ… çœŸå®MT5æ¨¡å¼: é€šè¿‡ï¼ˆæˆ–è·³è¿‡ï¼‰")
    else:
        print("âŒ çœŸå®MT5æ¨¡å¼: å¤±è´¥")
    
    if mock_success:
        print("\nğŸ‰ ç³»ç»Ÿä¿®å¤éªŒè¯é€šè¿‡ï¼")
        print("ğŸ’¡ ç°åœ¨å¯ä»¥æ­£å¸¸è¿è¡Œç³»ç»Ÿäº†")
        return True
    else:
        print("\nâš ï¸  ç³»ç»Ÿä¿®å¤éªŒè¯å¤±è´¥ï¼Œéœ€è¦è¿›ä¸€æ­¥è°ƒè¯•")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
"""
éªŒè¯æ¨¡å—å‘½åå†²çªä¿®å¤ - ä¿®å¤å¾ªç¯å¯¼å…¥ç‰ˆæœ¬
"""
import sys
import os
sys.path.append(os.path.dirname(__file__))

def test_imports():
    """æµ‹è¯•æ‰€æœ‰å¯¼å…¥æ˜¯å¦æ­£å¸¸"""
    print("ğŸ”§ æµ‹è¯•æ¨¡å—å¯¼å…¥...")
    
    tests = [
        ("æ ‡å‡†åº“ logging", lambda: __import__('logging')),
        ("æ ‡å‡†åº“ time", lambda: __import__('time')),
        ("è‡ªå®šä¹‰æ—¥å¿—åŒ…", lambda: __import__('custom_logging')),
        ("å¼‚å¸¸ç±»", lambda: __import__('exceptions.trading_exceptions')),
        ("å¼‚å¸¸å¤„ç†å™¨", lambda: __import__('exceptions.exception_handler')),
        ("æ•°æ®ç®¡ç†å™¨", lambda: __import__('data_manager')),
        ("ä¸»æ—¥å¿—å™¨", lambda: __import__('logger')),
    ]
    
    all_passed = True
    
    for name, import_func in tests:
        try:
            module = import_func()
            print(f"âœ… {name} å¯¼å…¥æˆåŠŸ")
        except Exception as e:
            print(f"âŒ {name} å¯¼å…¥å¤±è´¥: {e}")
            all_passed = False
    
    return all_passed

def test_exception_classes():
    """æµ‹è¯•å¼‚å¸¸ç±»å¯¼å…¥"""
    print("\nğŸš¨ æµ‹è¯•å¼‚å¸¸ç±»å¯¼å…¥...")
    
    try:
        from exceptions.trading_exceptions import (
            TradingException,
            DataException,
            MT5ConnectionException
        )
        
        # æµ‹è¯•åˆ›å»ºå¼‚å¸¸å®ä¾‹
        trading_exc = TradingException("æµ‹è¯•äº¤æ˜“å¼‚å¸¸")
        data_exc = DataException("æµ‹è¯•æ•°æ®å¼‚å¸¸") 
        mt5_exc = MT5ConnectionException("æµ‹è¯•MT5è¿æ¥å¼‚å¸¸")
        
        print("âœ… å¼‚å¸¸ç±»å¯¼å…¥å’Œå®ä¾‹åŒ–æˆåŠŸ")
        return True
        
    except Exception as e:
        print(f"âŒ å¼‚å¸¸ç±»å¯¼å…¥å¤±è´¥: {e}")
        return False

def test_exception_handler_import():
    """æµ‹è¯•å¼‚å¸¸å¤„ç†å™¨å¯¼å…¥"""
    print("\nğŸ”§ æµ‹è¯•å¼‚å¸¸å¤„ç†å™¨å¯¼å…¥...")
    
    try:
        from exceptions.exception_handler import (
            ExceptionHandler,
            exception_handler,
            handle_exceptions,
            handle_specific_exceptions
        )
        
        print("âœ… å¼‚å¸¸å¤„ç†å™¨å¯¼å…¥æˆåŠŸ")
        return True
        
    except Exception as e:
        print(f"âŒ å¼‚å¸¸å¤„ç†å™¨å¯¼å…¥å¤±è´¥: {e}")
        return False

def test_logger_functionality():
    """æµ‹è¯•æ—¥å¿—å™¨åŠŸèƒ½"""
    print("\nğŸ“ æµ‹è¯•æ—¥å¿—å™¨åŠŸèƒ½...")
    
    try:
        from logger import logger
        
        # æµ‹è¯•å„ç§æ—¥å¿—çº§åˆ«
        logger.debug("è°ƒè¯•ä¿¡æ¯æµ‹è¯•")
        logger.info("æ™®é€šä¿¡æ¯æµ‹è¯•")
        logger.warning("è­¦å‘Šä¿¡æ¯æµ‹è¯•")
        logger.error("é”™è¯¯ä¿¡æ¯æµ‹è¯•")
        
        # æµ‹è¯•å¸¦é¢å¤–æ•°æ®çš„æ—¥å¿—
        logger.info("å¸¦é¢å¤–æ•°æ®çš„æ—¥å¿—", extra_data={'user': 'test', 'action': 'testing'})
        
        # æµ‹è¯•æ€§èƒ½æ—¥å¿—
        logger.performance("æ€§èƒ½æµ‹è¯•", execution_time=0.123)
        
        print("âœ… æ—¥å¿—å™¨åŠŸèƒ½æµ‹è¯•æˆåŠŸ")
        return True
        
    except Exception as e:
        print(f"âŒ æ—¥å¿—å™¨åŠŸèƒ½æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_exception_handler_functionality():
    """æµ‹è¯•å¼‚å¸¸å¤„ç†å™¨åŠŸèƒ½"""
    print("\nğŸš¨ æµ‹è¯•å¼‚å¸¸å¤„ç†å™¨åŠŸèƒ½...")
    
    try:
        from exceptions.exception_handler import exception_handler
        from exceptions.trading_exceptions import TradingException
        
        # æµ‹è¯•è‡ªå®šä¹‰å¼‚å¸¸å¤„ç†
        test_exception = TradingException("æµ‹è¯•å¼‚å¸¸", error_code="TEST_ERROR")
        result = exception_handler.handle(test_exception, {'test_context': 'value'})
        
        if result:
            print("âœ… å¼‚å¸¸å¤„ç†å™¨æµ‹è¯•æˆåŠŸ")
        else:
            print("âŒ å¼‚å¸¸å¤„ç†å™¨å¤„ç†å¤±è´¥")
            return False
        
        # æµ‹è¯•é€šç”¨å¼‚å¸¸å¤„ç†
        try:
            raise ValueError("æµ‹è¯•å€¼é”™è¯¯")
        except Exception as e:
            result = exception_handler.handle(e, {'function': 'test_exception_handler'})
            if result:
                print("âœ… é€šç”¨å¼‚å¸¸å¤„ç†æµ‹è¯•æˆåŠŸ")
            else:
                print("âŒ é€šç”¨å¼‚å¸¸å¤„ç†å¤±è´¥")
                return False
        
        return True
        
    except Exception as e:
        print(f"âŒ å¼‚å¸¸å¤„ç†å™¨åŠŸèƒ½æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_data_manager():
    """æµ‹è¯•æ•°æ®ç®¡ç†å™¨"""
    print("\nğŸ“Š æµ‹è¯•æ•°æ®ç®¡ç†å™¨...")
    
    try:
        from data_manager import DataManager
        
        config = {
            'symbols': ['XAUUSD'],
            'timeframes': ['15m'],
            'test_mode': True,
            'use_mt5': False
        }
        
        dm = DataManager(config)
        
        # æµ‹è¯•åŸºæœ¬åŠŸèƒ½
        data = dm.get_market_data('XAUUSD', '15m', 10)
        if not data.empty:
            print(f"âœ… æ•°æ®ç®¡ç†å™¨æµ‹è¯•æˆåŠŸ: è·å– {len(data)} æ¡æ•°æ®")
        else:
            print("âŒ æ•°æ®ç®¡ç†å™¨è·å–æ•°æ®å¤±è´¥")
            return False
        
        # æµ‹è¯•æŠ€æœ¯æŒ‡æ ‡
        indicators = dm.calculate_technical_indicators('XAUUSD', '15m')
        if indicators:
            print(f"âœ… æŠ€æœ¯æŒ‡æ ‡è®¡ç®—æˆåŠŸ: {len(indicators)} ä¸ªæŒ‡æ ‡")
        else:
            print("âŒ æŠ€æœ¯æŒ‡æ ‡è®¡ç®—å¤±è´¥")
            return False
        
        dm.disconnect()
        return True
        
    except Exception as e:
        print(f"âŒ æ•°æ®ç®¡ç†å™¨æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_exception_decorators():
    """æµ‹è¯•å¼‚å¸¸è£…é¥°å™¨"""
    print("\nğŸ¯ æµ‹è¯•å¼‚å¸¸è£…é¥°å™¨...")
    
    try:
        from exceptions.exception_handler import handle_exceptions
        
        # æµ‹è¯•è£…é¥°å™¨åŠŸèƒ½
        @handle_exceptions(default_return="è£…é¥°å™¨æµ‹è¯•è¿”å›å€¼")
        def test_function(should_fail=False):
            if should_fail:
                raise ValueError("æµ‹è¯•å¼‚å¸¸")
            return "æ­£å¸¸è¿”å›å€¼"
        
        # æµ‹è¯•æ­£å¸¸æƒ…å†µ
        result1 = test_function(should_fail=False)
        if result1 == "æ­£å¸¸è¿”å›å€¼":
            print("âœ… è£…é¥°å™¨æ­£å¸¸æƒ…å†µæµ‹è¯•æˆåŠŸ")
        else:
            print("âŒ è£…é¥°å™¨æ­£å¸¸æƒ…å†µæµ‹è¯•å¤±è´¥")
            return False
        
        # æµ‹è¯•å¼‚å¸¸æƒ…å†µ
        result2 = test_function(should_fail=True)
        if result2 == "è£…é¥°å™¨æµ‹è¯•è¿”å›å€¼":
            print("âœ… è£…é¥°å™¨å¼‚å¸¸æƒ…å†µæµ‹è¯•æˆåŠŸ")
        else:
            print("âŒ è£…é¥°å™¨å¼‚å¸¸æƒ…å†µæµ‹è¯•å¤±è´¥")
            return False
        
        return True
        
    except Exception as e:
        print(f"âŒ å¼‚å¸¸è£…é¥°å™¨æµ‹è¯•å¤±è´¥: {e}")
        return False

def main():
    """ä¸»æµ‹è¯•å‡½æ•°"""
    print("ğŸš€ å¼€å§‹æ¨¡å—å‘½åå†²çªå’Œå¾ªç¯å¯¼å…¥ä¿®å¤éªŒè¯...\n")
    
    tests = [
        test_imports,
        test_exception_classes,
        test_exception_handler_import,
        test_logger_functionality,
        test_exception_handler_functionality,
        test_exception_decorators,
        test_data_manager
    ]
    
    results = []
    for test in tests:
        try:
            result = test()
            results.append(result)
            print("")  # ç©ºè¡Œåˆ†éš”
        except Exception as e:
            print(f"âŒ æµ‹è¯•å¼‚å¸¸: {e}")
            import traceback
            traceback.print_exc()
            results.append(False)
    
    # æ±‡æ€»ç»“æœ
    print("="*60)
    print("ğŸ“‹ æ¨¡å—ä¿®å¤éªŒè¯ç»“æœ:")
    passed = sum(results)
    total = len(results)
    
    print(f"âœ… é€šè¿‡: {passed}/{total}")
    print(f"âŒ å¤±è´¥: {total - passed}/{total}")
    
    if passed == total:
        print("\nğŸ‰ æ‰€æœ‰æ¨¡å—å¯¼å…¥å’ŒåŠŸèƒ½æµ‹è¯•é€šè¿‡!")
        print("ğŸ’¡ æ¨¡å—å‘½åå†²çªå’Œå¾ªç¯å¯¼å…¥å·²æˆåŠŸä¿®å¤!")
        return True
    else:
        print("\nâš ï¸  éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œéœ€è¦è¿›ä¸€æ­¥è°ƒè¯•")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
# test_mt5.py
import MetaTrader5 as mt5

def test_mt5_connection(account, password, server):
    if not mt5.initialize():
        print("MT5åˆå§‹åŒ–å¤±è´¥")
        return False
    
    authorized = mt5.login(account, password, server)
    
    if authorized:
        print("ç™»å½•æˆåŠŸï¼")
        print(f"è´¦æˆ·ä½™é¢: {mt5.account_info().balance}")
        return True
    else:
        print("ç™»å½•å¤±è´¥")
        return False

if __name__ == "__main__":
    # ä½¿ç”¨æ‚¨çš„çœŸå®è´¦æˆ·ä¿¡æ¯
    test_mt5_connection(160618052, "Lrsh77635918@", "ForexTimeFXTM-Demo01")
# test_mt5_connection.py
import MetaTrader5 as mt5
from config import TradingConfig

def test_mt5_connection():
    """æµ‹è¯•MT5è¿æ¥"""
    try:
        # åŠ è½½é…ç½®
        config = TradingConfig.from_yaml('config/production.yaml')
        
        # åˆå§‹åŒ–MT5
        if not mt5.initialize():
            print("âŒ MT5åˆå§‹åŒ–å¤±è´¥")
            return False
        
        # ç™»å½•è´¦æˆ·
        authorized = mt5.login(
            login=config.mt5_account,
            password=config.mt5_password,
            server=config.mt5_server
        )
        
        if authorized:
            account_info = mt5.account_info()
            print(f"âœ… MT5ç™»å½•æˆåŠŸï¼")
            print(f"   è´¦æˆ·: {account_info.login}")
            print(f"   ä½™é¢: ${account_info.balance}")
            print(f"   æœåŠ¡å™¨: {config.mt5_server}")
            return True
        else:
            print(f"âŒ MT5ç™»å½•å¤±è´¥: {mt5.last_error()}")
            return False
            
    except Exception as e:
        print(f"âŒ MT5è¿æ¥å¼‚å¸¸: {str(e)}")
        return False
    finally:
        mt5.shutdown()

if __name__ == "__main__":
    success = test_mt5_connection()
    if success:
        print("\nğŸ‰ MT5è¿æ¥æµ‹è¯•é€šè¿‡ï¼")
    else:
        print("\nâŒ MT5è¿æ¥æµ‹è¯•å¤±è´¥")
"""
ç¨³å®šçš„MT5è¿æ¥æµ‹è¯•
"""
import sys
import os
import time
sys.path.append(os.path.dirname(__file__))
import MetaTrader5 as mt5

from mt5_connection_manager import connection_manager
from security.env_manager import env_manager

def test_single_connection():
    """æµ‹è¯•å•æ¬¡è¿æ¥"""
    print("ğŸ”— æµ‹è¯•å•æ¬¡MT5è¿æ¥...")
    
    try:
        mt5_config = env_manager.get_mt5_config()
        
        start_time = time.time()
        connected = connection_manager.connect(
            account=int(mt5_config['account']),
            password=mt5_config['password'],
            server=mt5_config['server']
        )
        connect_time = time.time() - start_time
        
        if connected:
            print(f"âœ… è¿æ¥æˆåŠŸ - è€—æ—¶: {connect_time:.2f}ç§’")
            
            # æ£€æŸ¥è¿æ¥çŠ¶æ€
            info = connection_manager.get_connection_info()
            print(f"   è¿æ¥ä¿¡æ¯: {info}")
            
            # ç­‰å¾…å‡ ç§’
            time.sleep(3)
            
            # æ–­å¼€è¿æ¥
            disconnected = connection_manager.disconnect()
            if disconnected:
                print("âœ… æ–­å¼€è¿æ¥æˆåŠŸ")
            else:
                print("âŒ æ–­å¼€è¿æ¥å¤±è´¥")
            
            return True
        else:
            print("âŒ è¿æ¥å¤±è´¥")
            return False
            
    except Exception as e:
        print(f"âŒ è¿æ¥æµ‹è¯•å¼‚å¸¸: {e}")
        return False

def test_multiple_connections():
    """æµ‹è¯•å¤šæ¬¡è¿æ¥ï¼ˆæ¨¡æ‹Ÿæµ‹è¯•åœºæ™¯ï¼‰"""
    print("\nğŸ”„ æµ‹è¯•å¤šæ¬¡MT5è¿æ¥...")
    
    try:
        mt5_config = env_manager.get_mt5_config()
        results = []
        
        # æ¨¡æ‹Ÿæµ‹è¯•ä¸­çš„å¤šæ¬¡è¿æ¥
        for i in range(3):
            print(f"   ç¬¬ {i+1} æ¬¡è¿æ¥...")
            
            connected = connection_manager.connect(
                account=int(mt5_config['account']),
                password=mt5_config['password'],
                server=mt5_config['server']
            )
            
            if connected:
                print(f"   âœ… ç¬¬ {i+1} æ¬¡è¿æ¥æˆåŠŸ")
                results.append(True)
                
                # æ¨¡æ‹Ÿä¸€äº›æ“ä½œ
                time.sleep(1)
                
                # æ–­å¼€
                connection_manager.disconnect()
                print(f"   âœ… ç¬¬ {i+1} æ¬¡æ–­å¼€æˆåŠŸ")
            else:
                print(f"   âŒ ç¬¬ {i+1} æ¬¡è¿æ¥å¤±è´¥")
                results.append(False)
        
        success_count = sum(results)
        print(f"å¤šæ¬¡è¿æ¥æµ‹è¯•ç»“æœ: {success_count}/3 æˆåŠŸ")
        
        return success_count == 3
        
    except Exception as e:
        print(f"âŒ å¤šæ¬¡è¿æ¥æµ‹è¯•å¼‚å¸¸: {e}")
        return False

def test_connection_stability():
    """æµ‹è¯•è¿æ¥ç¨³å®šæ€§"""
    print("\nâš¡ æµ‹è¯•è¿æ¥ç¨³å®šæ€§...")
    
    try:
        mt5_config = env_manager.get_mt5_config()
        
        # é•¿æ—¶é—´ä¿æŒè¿æ¥
        connected = connection_manager.connect(
            account=int(mt5_config['account']),
            password=mt5_config['password'],
            server=mt5_config['server']
        )
        
        if not connected:
            print("âŒ ç¨³å®šæ€§æµ‹è¯•è¿æ¥å¤±è´¥")
            return False
        
        print("âœ… è¿æ¥å»ºç«‹ï¼Œæµ‹è¯•30ç§’ç¨³å®šæ€§...")
        
        # ç›‘æ§è¿æ¥30ç§’
        for i in range(30):
            info = connection_manager.get_connection_info()
            print(f"   {i+1}/30ç§’ - è¿æ¥çŠ¶æ€: {info['is_connected']}, å¼•ç”¨è®¡æ•°: {info['connection_count']}")
            
            # æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡è´¦æˆ·ä¿¡æ¯
            if (i + 1) % 5 == 0:
                try:
                    account_info = mt5.account_info()
                    if account_info:
                        print(f"      è´¦æˆ·çŠ¶æ€æ­£å¸¸: {account_info.login}, ä½™é¢: {account_info.balance}")
                    else:
                        print("      âš ï¸ æ— æ³•è·å–è´¦æˆ·ä¿¡æ¯")
                except Exception as e:
                    print(f"      âš ï¸ æ£€æŸ¥è´¦æˆ·çŠ¶æ€å¼‚å¸¸: {e}")
            
            time.sleep(1)
        
        # æ–­å¼€è¿æ¥
        connection_manager.disconnect()
        print("âœ… ç¨³å®šæ€§æµ‹è¯•å®Œæˆ")
        return True
        
    except Exception as e:
        print(f"âŒ ç¨³å®šæ€§æµ‹è¯•å¼‚å¸¸: {e}")
        # ç¡®ä¿æ–­å¼€è¿æ¥
        connection_manager.disconnect(force=True)
        return False

def main():
    """ä¸»æµ‹è¯•å‡½æ•°"""
    print("ğŸš€ å¼€å§‹MT5è¿æ¥ç¨³å®šæ€§æµ‹è¯•...\n")
    
    # éªŒè¯ç¯å¢ƒå˜é‡
    if not env_manager.validate_environment():
        print("âŒ ç¯å¢ƒå˜é‡éªŒè¯å¤±è´¥")
        return False
    
    tests = [
        test_single_connection,
        test_multiple_connections,
        test_connection_stability
    ]
    
    results = []
    for test in tests:
        try:
            result = test()
            results.append(result)
            print("")  # ç©ºè¡Œåˆ†éš”
        except Exception as e:
            print(f"âŒ æµ‹è¯•å¼‚å¸¸: {e}")
            results.append(False)
    
    # æ±‡æ€»ç»“æœ
    print("="*60)
    print("ğŸ“‹ MT5è¿æ¥ç¨³å®šæ€§æµ‹è¯•ç»“æœ:")
    passed = sum(results)
    total = len(results)
    
    print(f"âœ… é€šè¿‡: {passed}/{total}")
    print(f"âŒ å¤±è´¥: {total - passed}/{total}")
    
    if passed == total:
        print("\nğŸ‰ MT5è¿æ¥ç¨³å®šæ€§æµ‹è¯•é€šè¿‡!")
        print("ğŸ’¡ è¿æ¥ç®¡ç†å™¨å¯ä»¥æœ‰æ•ˆç®¡ç†MT5è¿æ¥!")
        return True
    else:
        print("\nâš ï¸  è¿æ¥ç¨³å®šæ€§æµ‹è¯•å‘ç°é—®é¢˜")
        print("ğŸ’¡ å»ºè®®ä½¿ç”¨æ¨¡æ‹Ÿæ¨¡å¼è¿›è¡Œè‡ªåŠ¨åŒ–æµ‹è¯•")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
"""
çœŸå®æ•°æ®é›†æˆæµ‹è¯•
"""
import sys
import os
sys.path.append(os.path.dirname(__file__))

from data_providers.mt5_data_provider import MT5DataProvider
from data_providers.mock_data_provider import MockDataProvider
from data_manager import DataManager
from security.env_manager import env_manager

def test_mt5_data_provider():
    """æµ‹è¯•MT5æ•°æ®æä¾›è€…"""
    print("ğŸ”— æµ‹è¯•MT5æ•°æ®æä¾›è€…...")
    
    try:
        # è·å–MT5é…ç½®
        mt5_config = env_manager.get_mt5_config()
        config = {
            'mt5_account': int(mt5_config['account']),
            'mt5_password': mt5_config['password'],
            'mt5_server': mt5_config['server'],
            'symbols': ['XAUUSD'],
            'timeframes': ['15m', '1h']
        }
        
        provider = MT5DataProvider(config)
        
        # æµ‹è¯•è¿æ¥
        if provider.connect():
            print("âœ… MT5æ•°æ®æä¾›è€…è¿æ¥æˆåŠŸ")
            
            # æµ‹è¯•è·å–å†å²æ•°æ®
            data = provider.get_historical_data('XAUUSD', '15m', 10)
            if not data.empty:
                print(f"âœ… å†å²æ•°æ®è·å–æˆåŠŸ: {len(data)} æ¡è®°å½•")
                print(f"   æ•°æ®èŒƒå›´: {data.index[0]} åˆ° {data.index[-1]}")
                print(f"   ä»·æ ¼èŒƒå›´: {data['low'].min():.2f} - {data['high'].max():.2f}")
            else:
                print("âŒ å†å²æ•°æ®è·å–å¤±è´¥")
                return False
            
            # æµ‹è¯•è·å–å½“å‰æ•°æ®
            current_data = provider.get_current_data('XAUUSD')
            if current_data:
                print(f"âœ… å½“å‰æ•°æ®è·å–æˆåŠŸ:")
                print(f"   ä¹°ä»·: {current_data['bid']:.2f}")
                print(f"   å–ä»·: {current_data['ask']:.2f}")
                print(f"   ç‚¹å·®: {current_data['spread']:.4f}")
            else:
                print("âŒ å½“å‰æ•°æ®è·å–å¤±è´¥")
                return False
            
            provider.disconnect()
            return True
        else:
            print("âŒ MT5æ•°æ®æä¾›è€…è¿æ¥å¤±è´¥")
            return False
            
    except Exception as e:
        print(f"âŒ MT5æ•°æ®æä¾›è€…æµ‹è¯•å¼‚å¸¸: {e}")
        return False

def test_mock_data_provider():
    """æµ‹è¯•æ¨¡æ‹Ÿæ•°æ®æä¾›è€…"""
    print("\nğŸ”§ æµ‹è¯•æ¨¡æ‹Ÿæ•°æ®æä¾›è€…...")
    
    try:
        config = {
            'symbols': ['XAUUSD'],
            'timeframes': ['15m']
        }
        
        provider = MockDataProvider(config)
        
        # æµ‹è¯•è·å–å†å²æ•°æ®
        data = provider.get_historical_data('XAUUSD', '15m', 10)
        if not data.empty:
            print(f"âœ… æ¨¡æ‹Ÿå†å²æ•°æ®ç”ŸæˆæˆåŠŸ: {len(data)} æ¡è®°å½•")
        else:
            print("âŒ æ¨¡æ‹Ÿå†å²æ•°æ®ç”Ÿæˆå¤±è´¥")
            return False
        
        # æµ‹è¯•è·å–å½“å‰æ•°æ®
        current_data = provider.get_current_data('XAUUSD')
        if current_data:
            print(f"âœ… æ¨¡æ‹Ÿå½“å‰æ•°æ®ç”ŸæˆæˆåŠŸ")
        else:
            print("âŒ æ¨¡æ‹Ÿå½“å‰æ•°æ®ç”Ÿæˆå¤±è´¥")
            return False
        
        return True
        
    except Exception as e:
        print(f"âŒ æ¨¡æ‹Ÿæ•°æ®æä¾›è€…æµ‹è¯•å¼‚å¸¸: {e}")
        return False

def test_data_manager_with_real_data():
    """æµ‹è¯•æ•°æ®ç®¡ç†å™¨ä¸çœŸå®æ•°æ®é›†æˆ"""
    print("\nğŸ“Š æµ‹è¯•æ•°æ®ç®¡ç†å™¨ä¸çœŸå®æ•°æ®é›†æˆ...")
    
    try:
        # è·å–MT5é…ç½®
        mt5_config = env_manager.get_mt5_config()
        config = {
            'mt5_account': int(mt5_config['account']),
            'mt5_password': mt5_config['password'],
            'mt5_server': mt5_config['server'],
            'symbols': ['XAUUSD'],
            'timeframes': ['15m'],
            'use_mt5': True,
            'test_mode': False
        }
        
        data_manager = DataManager(config)
        
        # æµ‹è¯•è·å–å¸‚åœºæ•°æ®
        data = data_manager.get_market_data('XAUUSD', '15m', 20)
        if not data.empty:
            print(f"âœ… æ•°æ®ç®¡ç†å™¨å¸‚åœºæ•°æ®è·å–æˆåŠŸ: {len(data)} æ¡è®°å½•")
            print(f"   ä½¿ç”¨çš„æ•°æ®æä¾›è€…: {data_manager.data_provider.__class__.__name__}")
        else:
            print("âŒ æ•°æ®ç®¡ç†å™¨å¸‚åœºæ•°æ®è·å–å¤±è´¥")
            return False
        
        # æµ‹è¯•æŠ€æœ¯æŒ‡æ ‡è®¡ç®—
        indicators = data_manager.calculate_technical_indicators('XAUUSD', '15m')
        if indicators:
            print(f"âœ… æŠ€æœ¯æŒ‡æ ‡è®¡ç®—æˆåŠŸ: {len(indicators)} ä¸ªæŒ‡æ ‡")
            print(f"   RSI: {indicators.get('rsi', 0):.2f}")
            print(f"   MACD: {indicators.get('macd', 0):.5f}")
        else:
            print("âŒ æŠ€æœ¯æŒ‡æ ‡è®¡ç®—å¤±è´¥")
            return False
        
        # æµ‹è¯•ç¼“å­˜ç»Ÿè®¡
        stats = data_manager.get_cache_stats()
        print(f"âœ… ç¼“å­˜ç»Ÿè®¡: {stats['total_symbols']} ä¸ªå“ç§, æ•°æ®æä¾›è€…: {stats['data_provider']}")
        
        data_manager.disconnect()
        return True
        
    except Exception as e:
        print(f"âŒ æ•°æ®ç®¡ç†å™¨æµ‹è¯•å¼‚å¸¸: {e}")
        return False

def test_data_manager_with_mock_data():
    """æµ‹è¯•æ•°æ®ç®¡ç†å™¨ä¸æ¨¡æ‹Ÿæ•°æ®é›†æˆ"""
    print("\nğŸ”§ æµ‹è¯•æ•°æ®ç®¡ç†å™¨ä¸æ¨¡æ‹Ÿæ•°æ®é›†æˆ...")
    
    try:
        config = {
            'symbols': ['XAUUSD'],
            'timeframes': ['15m'],
            'use_mt5': False,
            'test_mode': True
        }
        
        data_manager = DataManager(config)
        
        # æµ‹è¯•è·å–å¸‚åœºæ•°æ®
        data = data_manager.get_market_data('XAUUSD', '15m', 10)
        if not data.empty:
            print(f"âœ… æ¨¡æ‹Ÿæ•°æ®ç®¡ç†å™¨å¸‚åœºæ•°æ®è·å–æˆåŠŸ: {len(data)} æ¡è®°å½•")
            print(f"   ä½¿ç”¨çš„æ•°æ®æä¾›è€…: {data_manager.data_provider.__class__.__name__}")
        else:
            print("âŒ æ¨¡æ‹Ÿæ•°æ®ç®¡ç†å™¨å¸‚åœºæ•°æ®è·å–å¤±è´¥")
            return False
        
        data_manager.disconnect()
        return True
        
    except Exception as e:
        print(f"âŒ æ¨¡æ‹Ÿæ•°æ®ç®¡ç†å™¨æµ‹è¯•å¼‚å¸¸: {e}")
        return False

def main():
    """ä¸»æµ‹è¯•å‡½æ•°"""
    print("ğŸš€ å¼€å§‹çœŸå®æ•°æ®é›†æˆæµ‹è¯•...\n")
    
    # éªŒè¯ç¯å¢ƒå˜é‡
    print("ğŸ” éªŒè¯ç¯å¢ƒå˜é‡...")
    if not env_manager.validate_environment():
        print("âŒ ç¯å¢ƒå˜é‡éªŒè¯å¤±è´¥")
        return False
    print("âœ… ç¯å¢ƒå˜é‡éªŒè¯é€šè¿‡\n")
    
    # è¿è¡Œæµ‹è¯•
    tests = [
        test_mock_data_provider,
        test_mt5_data_provider,
        test_data_manager_with_mock_data,
        test_data_manager_with_real_data
    ]
    
    results = []
    for test in tests:
        try:
            result = test()
            results.append(result)
            print("")  # ç©ºè¡Œåˆ†éš”
        except Exception as e:
            print(f"âŒ æµ‹è¯•å¼‚å¸¸: {e}")
            results.append(False)
    
    # æ±‡æ€»ç»“æœ
    print("="*60)
    print("ğŸ“‹ çœŸå®æ•°æ®é›†æˆæµ‹è¯•ç»“æœ:")
    passed = sum(results)
    total = len(results)
    
    print(f"âœ… é€šè¿‡: {passed}/{total}")
    print(f"âŒ å¤±è´¥: {total - passed}/{total}")
    
    if passed == total:
        print("\nğŸ‰ æ‰€æœ‰çœŸå®æ•°æ®é›†æˆæµ‹è¯•é€šè¿‡!")
        print("ğŸ’¡ ç³»ç»Ÿç°åœ¨å¯ä»¥ä½¿ç”¨çœŸå®MT5æ•°æ®è¿›è¡Œäº¤æ˜“!")
        return True
    else:
        print("\nâš ï¸  éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œä½†ç³»ç»Ÿä»å¯è¿è¡Œï¼ˆä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ï¼‰")
        print("ğŸ’¡ æ£€æŸ¥MT5è¿æ¥æˆ–ä½¿ç”¨æµ‹è¯•æ¨¡å¼ç»§ç»­å¼€å‘")
        return True  # å³ä½¿éƒ¨åˆ†å¤±è´¥ä¹Ÿè¿”å›Trueï¼Œå› ä¸ºæ¨¡æ‹Ÿæ¨¡å¼ä»å¯ç”¨

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
"""
ç³»ç»ŸåŠŸèƒ½éªŒè¯è„šæœ¬
"""
import sys
import os
sys.path.append(os.path.dirname(__file__))

from data_manager import DataManager
from trading_strategy import MultiTimeframeStrategy
from risk_manager import EnhancedRiskManager
from notification_service import NotificationService
from security.env_manager import env_manager

def test_data_manager():
    """æµ‹è¯•æ•°æ®ç®¡ç†å™¨"""
    print("ğŸ“Š æµ‹è¯•æ•°æ®ç®¡ç†å™¨...")
    try:
        config = {
            'symbols': ['XAUUSD'],
            'timeframes': ['15m']
        }
        dm = DataManager(config)
        
        # æµ‹è¯•å¸‚åœºæ•°æ®è·å–
        data = dm.get_market_data('XAUUSD', '15m', 10)
        print(f"âœ… å¸‚åœºæ•°æ®è·å–: {len(data)} æ¡è®°å½•")
        
        # æµ‹è¯•æŠ€æœ¯æŒ‡æ ‡è®¡ç®—
        indicators = dm.calculate_technical_indicators('XAUUSD', '15m')
        print(f"âœ… æŠ€æœ¯æŒ‡æ ‡è®¡ç®—: {len(indicators)} ä¸ªæŒ‡æ ‡")
        
        # æµ‹è¯•è´¦æˆ·ä¿¡æ¯
        account_info = dm.get_account_info()
        print(f"âœ… æ¨¡æ‹Ÿè´¦æˆ·ä¿¡æ¯: ä½™é¢ ${account_info['balance']}")
        
        return True
    except Exception as e:
        print(f"âŒ æ•°æ®ç®¡ç†å™¨æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_trading_strategy():
    """æµ‹è¯•äº¤æ˜“ç­–ç•¥"""
    print("ğŸ¯ æµ‹è¯•äº¤æ˜“ç­–ç•¥...")
    try:
        config = {
            'symbols': ['XAUUSD'],
            'timeframes': ['15m']
        }
        strategy = MultiTimeframeStrategy(config)
        
        # åˆ›å»ºæµ‹è¯•æ•°æ®
        test_data = {
            'XAUUSD': {
                'timeframes': {
                    '15m': 'mock_data'  # ç®€åŒ–æµ‹è¯•
                },
                'indicators': {
                    'rsi': 50,
                    'macd': 0.1
                },
                'current_price': {
                    'last': 1805.0
                }
            }
        }
        
        signal = strategy.generate_signal(test_data)
        print(f"âœ… ä¿¡å·ç”Ÿæˆ: {signal['signal_type']} - {signal['reason']}")
        
        validation = strategy.validate_signal(signal)
        print(f"âœ… ä¿¡å·éªŒè¯: {validation}")
        
        return True
    except Exception as e:
        print(f"âŒ äº¤æ˜“ç­–ç•¥æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_risk_manager():
    """æµ‹è¯•é£é™©ç®¡ç†"""
    print("ğŸ›¡ï¸ æµ‹è¯•é£é™©ç®¡ç†...")
    try:
        config = {
            'per_trade_risk': 0.01,
            'max_daily_risk': 0.03,
            'max_drawdown': 0.05
        }
        risk_mgr = EnhancedRiskManager(config)
        
        # æµ‹è¯•ä¿¡å·
        test_signal = {
            'signal_type': 'buy',
            'direction': 'buy',
            'entry_price': 1805.0,
            'stop_loss': 1785.0,
            'take_profit': 1825.0,
            'confidence': 80,
            'symbol': 'XAUUSD'
        }
        
        test_account = {
            'balance': 10000.0,
            'equity': 10200.0,
            'free_margin': 9800.0
        }
        
        position_size = risk_mgr.calculate_position_size(test_signal, test_account)
        print(f"âœ… ä»“ä½è®¡ç®—: {position_size:.4f} æ‰‹")
        
        trade_validation = risk_mgr.validate_trade(test_signal, test_account)
        print(f"âœ… äº¤æ˜“éªŒè¯: {trade_validation}")
        
        return True
    except Exception as e:
        print(f"âŒ é£é™©ç®¡ç†æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_notification_service():
    """æµ‹è¯•é€šçŸ¥æœåŠ¡"""
    print("ğŸ“¢ æµ‹è¯•é€šçŸ¥æœåŠ¡...")
    try:
        config = {
            'telegram_token': None,  # ä¸å®é™…å‘é€ï¼Œåªæµ‹è¯•åŠŸèƒ½
            'telegram_chat_id': None
        }
        notification = NotificationService(config)
        
        # æµ‹è¯•æ¶ˆæ¯å‘é€ï¼ˆä¸ä¼šå®é™…å‘é€ï¼‰
        success = notification.send_message("ğŸ”§ ç³»ç»ŸåŠŸèƒ½æµ‹è¯•æ¶ˆæ¯", "info")
        print(f"âœ… é€šçŸ¥æœåŠ¡: {'å·¥ä½œæ­£å¸¸' if success else 'æ¨¡æ‹Ÿæ¨¡å¼'}")
        
        return True
    except Exception as e:
        print(f"âŒ é€šçŸ¥æœåŠ¡æµ‹è¯•å¤±è´¥: {e}")
        return False

def main():
    """ä¸»æµ‹è¯•å‡½æ•°"""
    print("ğŸš€ å¼€å§‹ç³»ç»ŸåŠŸèƒ½éªŒè¯...\n")
    
    # éªŒè¯ç¯å¢ƒå˜é‡
    print("ğŸ” éªŒè¯ç¯å¢ƒå˜é‡...")
    if not env_manager.validate_environment():
        print("âŒ ç¯å¢ƒå˜é‡éªŒè¯å¤±è´¥")
        return False
    print("âœ… ç¯å¢ƒå˜é‡éªŒè¯é€šè¿‡\n")
    
    # è¿è¡Œå„æ¨¡å—æµ‹è¯•
    tests = [
        test_data_manager,
        test_trading_strategy, 
        test_risk_manager,
        test_notification_service
    ]
    
    results = []
    for test in tests:
        try:
            result = test()
            results.append(result)
        except Exception as e:
            print(f"âŒ æµ‹è¯•å¼‚å¸¸: {e}")
            results.append(False)
    
    # æ±‡æ€»ç»“æœ
    print("\n" + "="*50)
    print("ğŸ“‹ æµ‹è¯•ç»“æœæ±‡æ€»:")
    passed = sum(results)
    total = len(results)
    
    print(f"âœ… é€šè¿‡: {passed}/{total}")
    print(f"âŒ å¤±è´¥: {total - passed}/{total}")
    
    if passed == total:
        print("\nğŸ‰ æ‰€æœ‰åŠŸèƒ½æµ‹è¯•é€šè¿‡!")
        return True
    else:
        print("\nâš ï¸  éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç›¸å…³é—®é¢˜")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
"""
äº¤æ˜“å¼•æ“æ¨¡å— - å¢å¼ºå¼‚å¸¸å¤„ç†ç‰ˆæœ¬
ç³»ç»Ÿçš„æ ¸å¿ƒåè°ƒå™¨ï¼Œæ•´åˆæ‰€æœ‰æ¨¡å—åŠŸèƒ½
"""
import time
import threading
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timedelta
import signal
import sys
import pandas as pd
import numpy as np

from interfaces import IDataProvider, ITradingStrategy, IRiskManager, IBrokerAdapter, INotificationService
from logger import logger, log_execution_time
from exceptions.exception_handler import handle_exceptions, handle_specific_exceptions
from exceptions.trading_exceptions import TradingException, DataException, BrokerException

class TradingEngine:
    """äº¤æ˜“å¼•æ“ - ç³»ç»Ÿæ ¸å¿ƒåè°ƒå™¨ - å¢å¼ºå¼‚å¸¸å¤„ç†"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.running = False
        self.initialized = False
        self.last_heartbeat = datetime.now()
        self.heartbeat_interval = timedelta(seconds=30)
        
        # æ¨¡å—å®ä¾‹
        self.data_provider: Optional[IDataProvider] = None
        self.strategy: Optional[ITradingStrategy] = None
        self.risk_manager: Optional[IRiskManager] = None
        self.broker_adapter: Optional[IBrokerAdapter] = None
        self.notification_service: Optional[INotificationService] = None
        
        # ç³»ç»ŸçŠ¶æ€
        self.system_status = {
            'start_time': datetime.now(),
            'last_signal_time': None,
            'last_trade_time': None,
            'total_signals': 0,
            'total_trades': 0,
            'successful_trades': 0,
            'failed_trades': 0,
            'current_positions': [],
            'system_health': 'unknown',
            'last_error': None,
            'error_count': 0
        }
        
        # ä¿¡å·å†å²
        self.signal_history: List[Dict] = []
        self.trade_history: List[Dict] = []
        
        # çº¿ç¨‹æ§åˆ¶
        self.monitor_thread = None
        self.emergency_stop = False
        
        # è·å–é…ç½®
        self.check_intervals = config.get('check_intervals', {})
        self.trading_hours = config.get('trading_hours', {})
    
    @handle_exceptions(default_return=False, log_level="CRITICAL")
    @log_execution_time
    def initialize(self) -> bool:
        """åˆå§‹åŒ–äº¤æ˜“å¼•æ“"""
        try:
            logger.info("å¼€å§‹åˆå§‹åŒ–äº¤æ˜“å¼•æ“...")
            
            # åˆå§‹åŒ–æ•°æ®æä¾›è€…
            from data_manager import DataManager
            self.data_provider = DataManager(self.config)
            logger.info("æ•°æ®ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ")
            
            # åˆå§‹åŒ–äº¤æ˜“ç­–ç•¥
            from trading_strategy import MultiTimeframeStrategy
            self.strategy = MultiTimeframeStrategy(self.config)
            logger.info("äº¤æ˜“ç­–ç•¥åˆå§‹åŒ–å®Œæˆ")
            
            # åˆå§‹åŒ–é£é™©ç®¡ç†å™¨
            from risk_manager import EnhancedRiskManager
            self.risk_manager = EnhancedRiskManager(self.config)
            logger.info("é£é™©ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ")
            
            # åˆå§‹åŒ–ç»çºªå•†é€‚é…å™¨ - æ ¹æ®é…ç½®é€‰æ‹©
            use_mt5 = self.config.get('use_mt5', True)
            test_mode = self.config.get('test_mode', False)
            
            if not use_mt5 or test_mode:
                # ä½¿ç”¨æ¨¡æ‹Ÿé€‚é…å™¨
                from broker_adapter_mock import MockBrokerAdapter
                self.broker_adapter = MockBrokerAdapter(self.config)
                logger.info("æ¨¡æ‹Ÿç»çºªå•†é€‚é…å™¨åˆå§‹åŒ–å®Œæˆï¼ˆæµ‹è¯•æ¨¡å¼ï¼‰")
            else:
                # ä½¿ç”¨çœŸå®MT5é€‚é…å™¨
                from broker_adapter import MT5BrokerAdapter
                self.broker_adapter = MT5BrokerAdapter(self.config)
                if self.broker_adapter.connect():
                    logger.info("MT5ç»çºªå•†é€‚é…å™¨è¿æ¥æˆåŠŸ")
                else:
                    logger.warning("MT5ç»çºªå•†é€‚é…å™¨è¿æ¥å¤±è´¥ï¼Œå°†åœ¨éœ€è¦æ—¶é‡è¯•")
            
            # åˆå§‹åŒ–é€šçŸ¥æœåŠ¡
            from notification_service import NotificationService
            self.notification_service = NotificationService(self.config)
            logger.info("é€šçŸ¥æœåŠ¡åˆå§‹åŒ–å®Œæˆ")
            
            # å¯åŠ¨ç›‘æ§çº¿ç¨‹
            self._start_monitor_thread()
            
            # æ³¨å†Œä¿¡å·å¤„ç†å™¨
            self._register_signal_handlers()
            
            self.initialized = True
            self.system_status['system_health'] = 'healthy'
            
            logger.info("äº¤æ˜“å¼•æ“åˆå§‹åŒ–å®Œæˆ")
            
            # å‘é€å¯åŠ¨é€šçŸ¥ï¼ˆä»…åœ¨éæµ‹è¯•æ¨¡å¼ï¼‰
            if not test_mode and self.notification_service:
                self.notification_service.send_message("âœ… äº¤æ˜“ç³»ç»Ÿå¯åŠ¨æˆåŠŸ", "info")
            else:
                logger.info("ğŸ”§ æµ‹è¯•æ¨¡å¼ - è·³è¿‡å®é™…é€šçŸ¥å‘é€")
            
            return True
            
        except Exception as e:
            self.system_status['system_health'] = 'unhealthy'
            self.system_status['last_error'] = str(e)
            logger.critical(
                f"äº¤æ˜“å¼•æ“åˆå§‹åŒ–å¤±è´¥: {str(e)}",
                extra_data={'config_keys': list(self.config.keys())}
            )
            return False
    
    @handle_exceptions(default_return=False, log_level="ERROR")
    @log_execution_time
    def start(self) -> bool:
        """å¯åŠ¨äº¤æ˜“å¼•æ“"""
        if not self.initialized:
            if not self.initialize():
                return False
        
        self.running = True
        logger.info("äº¤æ˜“å¼•æ“å¯åŠ¨")
        
        try:
            # ä¸»äº¤æ˜“å¾ªç¯
            while self.running and not self.emergency_stop:
                try:
                    self._run_trading_cycle()
                    
                    # æ ¹æ®ç³»ç»ŸçŠ¶æ€è°ƒæ•´æ£€æŸ¥é—´éš”
                    sleep_duration = self._calculate_sleep_duration()
                    
                    # ç­‰å¾…æŒ‡å®šæ—¶é—´
                    for i in range(sleep_duration, 0, -1):
                        if not self.running:
                            break
                        time.sleep(1)
                        if i % 30 == 0:
                            logger.debug(f"å‰©ä½™ç­‰å¾…æ—¶é—´: {i}ç§’")
                    
                except KeyboardInterrupt:
                    logger.info("æ”¶åˆ°é”®ç›˜ä¸­æ–­ä¿¡å·ï¼Œå‡†å¤‡å…³é—­ç³»ç»Ÿ")
                    self.stop()
                    break
                except Exception as e:
                    self.system_status['error_count'] += 1
                    self.system_status['last_error'] = str(e)
                    logger.error(
                        f"äº¤æ˜“å¾ªç¯å¼‚å¸¸: {str(e)}",
                        extra_data={'error_count': self.system_status['error_count']}
                    )
                    time.sleep(60)  # å‘ç”Ÿé”™è¯¯æ—¶ç­‰å¾…1åˆ†é’Ÿ
            
            return True
            
        except Exception as e:
            logger.critical(
                f"äº¤æ˜“å¼•æ“è¿è¡Œå¼‚å¸¸: {str(e)}",
                extra_data={'running': self.running, 'emergency_stop': self.emergency_stop}
            )
            return False
    
    @handle_exceptions(default_return=False, log_level="ERROR")
    @log_execution_time
    def stop(self) -> bool:
        """åœæ­¢äº¤æ˜“å¼•æ“"""
        logger.info("æ­£åœ¨åœæ­¢äº¤æ˜“å¼•æ“...")
        self.running = False
        self.emergency_stop = True
        
        # åœæ­¢ç›‘æ§çº¿ç¨‹
        if self.monitor_thread and self.monitor_thread.is_alive():
            self.monitor_thread.join(timeout=5)
        
        # æ–­å¼€ç»çºªå•†è¿æ¥
        if self.broker_adapter:
            try:
                self.broker_adapter.disconnect()
            except Exception as e:
                logger.error(f"æ–­å¼€ç»çºªå•†è¿æ¥å¼‚å¸¸: {str(e)}")
        
        # æ–­å¼€æ•°æ®æä¾›è€…è¿æ¥
        if self.data_provider:
            try:
                self.data_provider.disconnect()
            except Exception as e:
                logger.error(f"æ–­å¼€æ•°æ®æä¾›è€…è¿æ¥å¼‚å¸¸: {str(e)}")
        
        # å‘é€åœæ­¢é€šçŸ¥
        if self.notification_service and not self.config.get('test_mode', False):
            uptime = datetime.now() - self.system_status['start_time']
            self.notification_service.send_message(
                f"ğŸ›‘ äº¤æ˜“ç³»ç»Ÿå·²åœæ­¢\nè¿è¡Œæ—¶é—´: {uptime}", 
                "info"
            )
        
        logger.info("äº¤æ˜“å¼•æ“å·²åœæ­¢")
        return True
    
    @handle_exceptions(default_return=True, log_level="WARNING")
    def should_skip_trading(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦åº”è¯¥è·³è¿‡äº¤æ˜“ï¼ˆä»…æ£€æŸ¥å‘¨æœ«ï¼‰"""
        try:
            now = datetime.now()
            weekday = now.weekday()  # 0=å‘¨ä¸€, 6=å‘¨æ—¥
        
            #ä»…æ£€æŸ¥å‘¨æœ«ï¼šå‘¨å…­æˆ–å‘¨æ—¥è·³è¿‡äº¤æ˜“
            if weekday >= 5:  # 5=å‘¨å…­, 6=å‘¨æ—¥
                logger.info("å‘¨æœ«å¸‚åœºä¼‘å¸‚ï¼Œè·³è¿‡äº¤æ˜“")
                return True
        
            # é»„é‡‘å¸‚åœºæ— èŠ‚å‡æ—¥ï¼Œå‘¨ä¸€è‡³å‘¨äº”å…¨å¤©24å°æ—¶äº¤æ˜“
            return False
        
        except Exception as e:
            logger.error(f"æ£€æŸ¥æ˜¯å¦è·³è¿‡äº¤æ˜“å¼‚å¸¸: {str(e)}")
            return True  # å¼‚å¸¸æƒ…å†µä¸‹é»˜è®¤è·³è¿‡äº¤æ˜“

    @handle_exceptions(default_return=None, log_level="ERROR")
    def _run_trading_cycle(self):
        """æ‰§è¡Œå•ä¸ªäº¤æ˜“å‘¨æœŸ"""
        try:
            # æ£€æŸ¥æ˜¯å¦åº”è¯¥è·³è¿‡äº¤æ˜“
            if self.should_skip_trading():
                # æ ¹æ®å½“å‰æ—¶é—´è®¡ç®—åˆé€‚çš„ç­‰å¾…æ—¶é—´
                wait_time = self._calculate_wait_time()
                logger.info(f"å‘¨æœ«å¸‚åœºä¼‘å¸‚ï¼Œç­‰å¾… {wait_time} ç§’åå†æ¬¡æ£€æŸ¥")
                time.sleep(wait_time)
                return
        
            # åŸæœ‰çš„äº¤æ˜“é€»è¾‘...
            # è·å–å¸‚åœºæ•°æ®
            market_data = self._collect_market_data()
            if not market_data:
                logger.warning("æ— æ³•è·å–å¸‚åœºæ•°æ®ï¼Œè·³è¿‡æœ¬æ¬¡å‘¨æœŸ")
                time.sleep(60)  # ç­‰å¾…1åˆ†é’Ÿåé‡è¯•
                return
        
            # ç”Ÿæˆäº¤æ˜“ä¿¡å·
            signal = self.strategy.generate_signal(market_data)
            if not signal:
                logger.warning("ä¿¡å·ç”Ÿæˆå¤±è´¥")
                time.sleep(30)  # ç­‰å¾…30ç§’åé‡è¯•
                return
        
            # è®°å½•ä¿¡å·
            self._record_signal(signal)
        
            # å¦‚æœæ˜¯ä¸­æ€§ä¿¡å·ï¼Œè·³è¿‡æ‰§è¡Œ
            if signal.get('signal_type') == 'neutral':
                logger.debug("ä¸­æ€§ä¿¡å·ï¼Œè·³è¿‡æ‰§è¡Œ")
                return
        
            # è·å–è´¦æˆ·ä¿¡æ¯
            account_info = self.data_provider.get_account_info()
            if not account_info:
                logger.warning("æ— æ³•è·å–è´¦æˆ·ä¿¡æ¯ï¼Œè·³è¿‡æ‰§è¡Œ")
                time.sleep(60)  # ç­‰å¾…1åˆ†é’Ÿåé‡è¯•
                return
        
            # é£é™©éªŒè¯
            if not self.risk_manager.validate_trade(signal, account_info):
                logger.warning("äº¤æ˜“æœªé€šè¿‡é£é™©éªŒè¯")
                return
        
            # è®¡ç®—ä»“ä½å¤§å°
            position_size = self.risk_manager.calculate_position_size(signal, account_info)
            if position_size <= 0:
                logger.warning("ä»“ä½å¤§å°è®¡ç®—æ— æ•ˆ")
                return
        
            # å‡†å¤‡è®¢å•å‚æ•°
            order_params = self._prepare_order_params(signal, position_size)
        
            # æ‰§è¡Œäº¤æ˜“
            trade_result = self.broker_adapter.place_order(order_params)
        
            # è®°å½•äº¤æ˜“ç»“æœ
            self._record_trade(trade_result, signal)
        
            # å‘é€äº¤æ˜“é€šçŸ¥
            self._send_trade_notification(trade_result, signal)
        
        except Exception as e:
            self.system_status['error_count'] += 1
            self.system_status['last_error'] = str(e)
            logger.error(
                f"äº¤æ˜“å‘¨æœŸæ‰§è¡Œå¼‚å¸¸: {str(e)}",
                extra_data={'error_count': self.system_status['error_count']}
            )
            # å¼‚å¸¸æƒ…å†µä¸‹ç­‰å¾…ä¸€æ®µæ—¶é—´å†é‡è¯•
            time.sleep(60)

    # ... å…¶ä½™æ–¹æ³•ä¹Ÿç±»ä¼¼åœ°æ·»åŠ å¼‚å¸¸å¤„ç†è£…é¥°å™¨ ...

    @handle_exceptions(default_return=3600, log_level="ERROR")
    def _calculate_wait_time(self) -> int:
        """è®¡ç®—ç­‰å¾…æ—¶é—´ï¼ˆä»…è€ƒè™‘å‘¨æœ«ï¼‰"""
        # ... æ–¹æ³•å®ç° ...

    @handle_exceptions(default_return=120, log_level="ERROR")  
    def _calculate_sleep_duration(self) -> int:
        """è®¡ç®—ä¼‘çœ æ—¶é—´"""
        # ... æ–¹æ³•å®ç° ...

    @handle_exceptions(default_return=None, log_level="ERROR")
    def _collect_market_data(self) -> Optional[Dict[str, Any]]:
        """æ”¶é›†å¸‚åœºæ•°æ®"""
        # ... æ–¹æ³•å®ç° ...

    @handle_exceptions(default_return={}, log_level="ERROR")
    def _prepare_order_params(self, signal: Dict[str, Any], position_size: float) -> Dict[str, Any]:
        """å‡†å¤‡è®¢å•å‚æ•°"""
        # ... æ–¹æ³•å®ç° ...

    @handle_exceptions(default_return=None, log_level="ERROR")
    def _record_signal(self, signal: Dict[str, Any]):
        """è®°å½•ä¿¡å·å†å²"""
        # ... æ–¹æ³•å®ç° ...

    @handle_exceptions(default_return=None, log_level="ERROR")
    def _record_trade(self, trade_result: Dict[str, Any], signal: Dict[str, Any]):
        """è®°å½•äº¤æ˜“å†å²"""
        # ... æ–¹æ³•å®ç° ...

    @handle_exceptions(default_return=None, log_level="ERROR")
    def _send_trade_notification(self, trade_result: Dict[str, Any], signal: Dict[str, Any]):
        """å‘é€äº¤æ˜“é€šçŸ¥"""
        # ... æ–¹æ³•å®ç° ...

    # ... å…¶ä»–è¾…åŠ©æ–¹æ³• ...

    @handle_exceptions(default_return=False, log_level="ERROR")
    def _check_system_health(self) -> bool:
        """æ£€æŸ¥ç³»ç»Ÿå¥åº·çŠ¶æ€"""
        # ... æ–¹æ³•å®ç° ...

    @handle_exceptions(default_return=None, log_level="ERROR")
    def _update_heartbeat(self):
        """æ›´æ–°ç³»ç»Ÿå¿ƒè·³"""
        # ... æ–¹æ³•å®ç° ...

    @handle_exceptions(default_return=None, log_level="ERROR")
    def _start_monitor_thread(self):
        """å¯åŠ¨ç›‘æ§çº¿ç¨‹"""
        # ... æ–¹æ³•å®ç° ...

    @handle_exceptions(default_return=None, log_level="ERROR")
    def _monitor_system(self):
        """ç›‘æ§ç³»ç»ŸçŠ¶æ€"""
        # ... æ–¹æ³•å®ç° ...

    @handle_exceptions(default_return=None, log_level="ERROR")
    def _check_system_resources(self):
        """æ£€æŸ¥ç³»ç»Ÿèµ„æº"""
        # ... æ–¹æ³•å®ç° ...

    @handle_exceptions(default_return=None, log_level="ERROR")
    def _check_trading_performance(self):
        """æ£€æŸ¥äº¤æ˜“æ€§èƒ½"""
        # ... æ–¹æ³•å®ç° ...

    @handle_exceptions(default_return=None, log_level="ERROR")
    def _send_system_status_report(self):
        """å‘é€ç³»ç»ŸçŠ¶æ€æŠ¥å‘Š"""
        # ... æ–¹æ³•å®ç° ...

    @handle_exceptions(default_return=None, log_level="ERROR")
    def _register_signal_handlers(self):
        """æ³¨å†Œä¿¡å·å¤„ç†å™¨"""
        # ... æ–¹æ³•å®ç° ...

    @handle_exceptions(default_return={}, log_level="ERROR")
    def get_status(self) -> Dict[str, Any]:
        """è·å–ç³»ç»ŸçŠ¶æ€"""
        # ... æ–¹æ³•å®ç° ...

    @handle_exceptions(default_return=None, log_level="CRITICAL")
    def emergency_shutdown(self):
        """ç´§æ€¥å…³é—­ç³»ç»Ÿ"""
        # ... æ–¹æ³•å®ç° ...
"""
äº¤æ˜“ç­–ç•¥æ¨¡å— - å¢å¼ºå¼‚å¸¸å¤„ç†ç‰ˆæœ¬
"""
import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple, Any
from datetime import datetime
import functools

from interfaces import ITradingStrategy
from logger import logger, log_execution_time
from exceptions.exception_handler import handle_exceptions, handle_specific_exceptions
from exceptions.trading_exceptions import TradingStrategyException, SignalValidationException, ValidationException

# é”™è¯¯å¤„ç†è£…é¥°å™¨
def handle_signal_errors(func):
    """å¤„ç†ä¿¡å·ç”Ÿæˆé”™è¯¯çš„è£…é¥°å™¨"""
    @functools.wraps(func)
    def wrapper(self, data):
        try:
            return func(self, data)
        except KeyError as e:
            if 'timeframes' in str(e):
                logger.error(f"æ•°æ®ç¼ºå°‘timeframeså­—æ®µ: {e}")
                return self._create_neutral_signal("æ•°æ®ç¼ºå°‘timeframeså­—æ®µ")
            else:
                logger.error(f"æ•°æ®ç¼ºå°‘å­—æ®µ: {e}")
                return self._create_neutral_signal(f"æ•°æ®ç¼ºå°‘å­—æ®µ: {e}")
        except Exception as e:
            logger.error(f"ç”Ÿæˆä¿¡å·å¼‚å¸¸: {str(e)}")
            return self._create_neutral_signal(f"ç”Ÿæˆä¿¡å·å¼‚å¸¸: {str(e)}")
    return wrapper

class MultiTimeframeStrategy(ITradingStrategy):
    """å¤šæ—¶é—´æ¡†æ¶äº¤æ˜“ç­–ç•¥ - å¢å¼ºå¼‚å¸¸å¤„ç†"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.signal_history: List[Dict] = []
        self.max_history_size = 100
        
        # ç»Ÿè®¡ä¿¡æ¯
        self.stats = {
            'signals_generated': 0,
            'validation_errors': 0,
            'last_error': None
        }
    
    @handle_exceptions(default_return={})
    @log_execution_time
    def generate_signal(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """ç”Ÿæˆäº¤æ˜“ä¿¡å·ï¼ˆå®Œå…¨ç®€åŒ–ç‰ˆï¼‰"""
        try:
            # è°ƒè¯•ï¼šæ‰“å°ä¼ å…¥çš„æ•°æ®ç»“æ„
            logger.debug("å¼€å§‹ç”Ÿæˆäº¤æ˜“ä¿¡å·")
            
            # æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
            if not self._validate_data(data):
                logger.warning("æ•°æ®éªŒè¯å¤±è´¥")
                return self._create_neutral_signal("æ•°æ®ä¸å®Œæ•´")
            
            # è·å–ç¬¬ä¸€ä¸ªç¬¦å·çš„æ•°æ®
            symbols = list(data.keys())
            if not symbols:
                logger.warning("æ— ç¬¦å·æ•°æ®")
                return self._create_neutral_signal("æ— ç¬¦å·æ•°æ®")
            
            symbol = symbols[0]
            symbol_data = data[symbol]
            
            logger.debug(f"å¤„ç†ç¬¦å·: {symbol}")
            logger.debug(f"æ—¶é—´æ¡†æ¶: {list(symbol_data['timeframes'].keys())}")
            
            # è·å–å½“å‰ä»·æ ¼
            current_price = symbol_data['current_price'].get('last', 0)
            logger.debug(f"å½“å‰ä»·æ ¼: {current_price}")
            
            # ç®€å•ç­–ç•¥ï¼šåŸºäºå½“å‰ä»·æ ¼ç”Ÿæˆä¿¡å·
            if current_price > 1800:
                signal = self._create_buy_signal("price_above_1800", current_price, 0.8)
            elif current_price < 1790:
                signal = self._create_sell_signal("price_below_1790", current_price, 0.8)
            else:
                signal = self._create_neutral_signal("price_in_range")
            
            # éªŒè¯ä¿¡å·
            if not self.validate_signal(signal):
                self.stats['validation_errors'] += 1
                logger.warning(
                    "ä¿¡å·éªŒè¯å¤±è´¥ï¼Œè¿”å›ä¸­æ€§ä¿¡å·",
                    extra_data={'original_signal': signal}
                )
                return self._create_neutral_signal("ä¿¡å·éªŒè¯å¤±è´¥")
            
            self.stats['signals_generated'] += 1
            self._record_signal(signal)
            
            logger.info(
                f"ç”Ÿæˆä¿¡å·: {signal['signal_type']}",
                extra_data={
                    'signal_type': signal['signal_type'],
                    'direction': signal['direction'],
                    'confidence': signal['confidence'],
                    'reason': signal['reason']
                }
            )
            
            return signal
            
        except Exception as e:
            self.stats['last_error'] = str(e)
            logger.error(
                f"ç”Ÿæˆä¿¡å·å¼‚å¸¸: {str(e)}",
                extra_data={'data_keys': list(data.keys()) if data else 'æ— æ•°æ®'}
            )
            # å¼‚å¸¸å·²ç»åœ¨è£…é¥°å™¨ä¸­å¤„ç†ï¼Œè¿™é‡Œè¿”å›ä¸­æ€§ä¿¡å·
            return self._create_neutral_signal(f"ç”Ÿæˆä¿¡å·å¼‚å¸¸: {str(e)}")
    
    def _validate_data(self, data: Dict[str, Any]) -> bool:
        """éªŒè¯æ•°æ®å®Œæ•´æ€§"""
        try:
            if not data:
                logger.warning("æ•°æ®ä¸ºç©º")
                return False
            
            # æ£€æŸ¥æ˜¯å¦æœ‰ç¬¦å·æ•°æ®
            symbols = list(data.keys())
            if not symbols:
                logger.warning("æ— ç¬¦å·æ•°æ®")
                return False
            
            # æ£€æŸ¥ç¬¬ä¸€ä¸ªç¬¦å·çš„æ•°æ®
            first_symbol = symbols[0]
            symbol_data = data[first_symbol]
            
            # æ£€æŸ¥å¿…è¦å­—æ®µ
            required_fields = ['timeframes', 'indicators', 'current_price']
            for field in required_fields:
                if field not in symbol_data:
                    logger.warning(f"ç¬¦å·æ•°æ®ç¼ºå°‘å­—æ®µ: {field}")
                    return False
            
            # æ£€æŸ¥æ—¶é—´æ¡†æ¶æ•°æ®
            timeframes = symbol_data['timeframes']
            if not timeframes:
                logger.warning("æ— æ—¶é—´æ¡†æ¶æ•°æ®")
                return False
            
            # æ£€æŸ¥å½“å‰ä»·æ ¼
            current_price = symbol_data['current_price']
            if not current_price or 'last' not in current_price:
                logger.warning("å½“å‰ä»·æ ¼æ•°æ®ä¸å®Œæ•´")
                return False
            
            logger.debug("æ•°æ®éªŒè¯é€šè¿‡")
            return True
            
        except Exception as e:
            logger.error(f"éªŒè¯æ•°æ®å¼‚å¸¸: {str(e)}")
            return False
    
    def _create_buy_signal(self, reason: str, entry_price: float, confidence: float) -> Dict[str, Any]:
        """åˆ›å»ºä¹°å…¥ä¿¡å·"""
        signal = {
            'signal_type': 'buy',
            'direction': 'buy',
            'entry_price': entry_price,
            'stop_loss': entry_price * 0.99,  # 1% æ­¢æŸ
            'take_profit': entry_price * 1.02,  # 2% æ­¢ç›ˆ
            'risk_reward_ratio': "1:2",
            'confidence': confidence * 100,
            'timestamp': datetime.now(),
            'reason': reason,
            'symbol': 'XAUUSD'
        }
        
        logger.debug(
            f"åˆ›å»ºä¹°å…¥ä¿¡å·: {reason}",
            extra_data={'signal': signal}
        )
        
        return signal
    
    def _create_sell_signal(self, reason: str, entry_price: float, confidence: float) -> Dict[str, Any]:
        """åˆ›å»ºå–å‡ºä¿¡å·"""
        signal = {
            'signal_type': 'sell',
            'direction': 'sell',
            'entry_price': entry_price,
            'stop_loss': entry_price * 1.01,  # 1% æ­¢æŸ
            'take_profit': entry_price * 0.98,  # 2% æ­¢ç›ˆ
            'risk_reward_ratio': "1:2",
            'confidence': confidence * 100,
            'timestamp': datetime.now(),
            'reason': reason,
            'symbol': 'XAUUSD'
        }
        
        logger.debug(
            f"åˆ›å»ºå–å‡ºä¿¡å·: {reason}",
            extra_data={'signal': signal}
        )
        
        return signal
    
    def _create_neutral_signal(self, reason: str) -> Dict[str, Any]:
        """åˆ›å»ºä¸­æ€§ä¿¡å·"""
        signal = {
            'signal_type': 'neutral',
            'direction': 'hold',
            'entry_price': 0,
            'stop_loss': 0,
            'take_profit': 0,
            'risk_reward_ratio': "0:0",
            'confidence': 0,
            'timestamp': datetime.now(),
            'reason': reason,
            'symbol': 'XAUUSD'
        }
        
        logger.debug(
            f"åˆ›å»ºä¸­æ€§ä¿¡å·: {reason}",
            extra_data={'signal': signal}
        )
        
        return signal
    
    @handle_exceptions(default_return=False)
    def validate_signal(self, signal: Dict[str, Any]) -> bool:
        """éªŒè¯ä¿¡å·æœ‰æ•ˆæ€§"""
        try:
            if not signal:
                logger.warning("ä¿¡å·ä¸ºç©º")
                return False
            
            # æ£€æŸ¥å¿…è¦å­—æ®µ
            required_fields = ['signal_type', 'direction', 'entry_price', 'stop_loss', 'take_profit']
            for field in required_fields:
                if field not in signal:
                    logger.warning(f"ä¿¡å·ç¼ºå°‘å¿…è¦å­—æ®µ: {field}")
                    return False
            
            # å¯¹äºä¸­æ€§ä¿¡å·ï¼Œä¸éœ€è¦è¿›ä¸€æ­¥éªŒè¯
            if signal['signal_type'] == 'neutral':
                return True
            
            # éªŒè¯ä»·æ ¼åˆç†æ€§
            if signal['direction'] == 'buy':
                if signal['entry_price'] <= signal['stop_loss']:
                    logger.warning("ä¹°å…¥ä¿¡å·: å…¥åœºä»·æ ¼ä½äºæ­¢æŸä»·æ ¼")
                    return False
                if signal['entry_price'] >= signal['take_profit']:
                    logger.warning("ä¹°å…¥ä¿¡å·: å…¥åœºä»·æ ¼é«˜äºæ­¢ç›ˆä»·æ ¼")
                    return False
            else:  # sell
                if signal['entry_price'] >= signal['stop_loss']:
                    logger.warning("å–å‡ºä¿¡å·: å…¥åœºä»·æ ¼é«˜äºæ­¢æŸä»·æ ¼")
                    return False
                if signal['entry_price'] <= signal['take_profit']:
                    logger.warning("å–å‡ºä¿¡å·: å…¥åœºä»·æ ¼ä½äºæ­¢ç›ˆä»·æ ¼")
                    return False
            
            # éªŒè¯å¯ä¿¡åº¦
            if signal.get('confidence', 0) < self.config.get('min_confidence', 0.6) * 100:
                logger.warning(f"ä¿¡å·å¯ä¿¡åº¦ä¸è¶³: {signal.get('confidence', 0)}%")
                return False
            
            return True
            
        except Exception as e:
            logger.error(
                f"éªŒè¯ä¿¡å·å¼‚å¸¸: {str(e)}",
                extra_data={'signal': signal}
            )
            return False
    
    def _record_signal(self, signal: Dict[str, Any]):
        """è®°å½•ä¿¡å·å†å²"""
        self.signal_history.append(signal)
        
        # é™åˆ¶å†å²è®°å½•å¤§å°
        if len(self.signal_history) > self.max_history_size:
            self.signal_history = self.signal_history[-self.max_history_size:]
        
        logger.debug(
            f"è®°å½•ä¿¡å·: {signal['signal_type']}",
            extra_data={
                'signal_type': signal['signal_type'],
                'reason': signal['reason'],
                'history_size': len(self.signal_history)
            }
        )
    
    @handle_exceptions(default_return={})
    def get_strategy_stats(self) -> Dict[str, Any]:
        """è·å–ç­–ç•¥ç»Ÿè®¡ä¿¡æ¯"""
        stats = self.stats.copy()
        stats['history_size'] = len(self.signal_history)
        stats['current_time'] = datetime.now().isoformat()
        
        # è®¡ç®—ä¿¡å·ç±»å‹åˆ†å¸ƒ
        signal_types = {}
        for signal in self.signal_history:
            signal_type = signal.get('signal_type', 'unknown')
            signal_types[signal_type] = signal_types.get(signal_type, 0) + 1
        
        stats['signal_distribution'] = signal_types
        
        logger.debug(
            "è·å–ç­–ç•¥ç»Ÿè®¡ä¿¡æ¯",
            extra_data={'stats': stats}
        )
        
        return stats
# MT5 è´¦æˆ·é…ç½®
MT5_ACCOUNT=160618052
MT5_PASSWORD=Lrsh77635918@
MT5_SERVER=ForexTimeFXTM-Demo01

# å¤–éƒ¨APIé…ç½®  
HY_TOKEN=8tE8bq6InCxff5mUqQZfc9aGHP6NPD80Cr/k258SiLJ9CYW8HiMzU5pREYyvnbvjH4EUnzujYJ0K0brJdv8H4kWeABPgt+FOMgL80t65/UN0xEiqPIFgof8DNQijBcPGZCCgXJHLkOx5hlVr34QW6OxDKoODKKWeHDLHixm1c2AOuN9cCf60jxZD19TB0bhfKI7w0n7ZJilYpk/dvVsErvcW7MCFyrXdd7rfPLHxQPLt4U6UDSwF9cX0KvF1a1RXjHJ9D3BSZ/8B/s83ESyrRHZIQaiLaFNbW60UukOPqQOifOLfTEwYroo8i2GTzCFDqa1UNpxc+zprsehkVifoUcZcgYo95v85Arq8eSlHDqbIV0IxJ15oADYJZ8zgi5GoCw44Hy5h/tBBtt7OsiGYXR6d8mM5BAfdYSLYpGAPOAtCG9Wt+dgHlvvCZVOePGQC0g97SlpW+G+5N2qZGOXHr/3ob4GTtOG6Bj4pPb3hsBXQP3sEwxSNcEDCCYHVT+s3XehMc2l4I55waO15EFnLHq3i0cr6UHwxQXCyKLwTueYBfUK1HXstY0ViDWk0Hn12fAMCAL+nrAnmoJpE6YxunFp+I1i2+0ohyixd6vR4xEBb/KeeZe0A2U8zW5eEV2wVR6SUIln1a543rbthcXK33bIxxIPbb2LmsNqVlyGINNs=
HY_USER=7d5131e519874aee886b3492417b4428

# é‚®ä»¶é…ç½®ï¼ˆå¦‚æœéœ€è¦ï¼‰
EMAIL_PASSWORD=your_email_app_password

# Telegramé…ç½®ï¼ˆå¦‚æœéœ€è¦ï¼‰
TELEGRAM_BOT_TOKEN=your_telegram_bot_token
TELEGRAM_CHAT_ID=your_chat_id
# MT5 è´¦æˆ·é…ç½®
MT5_ACCOUNT=160618052
MT5_PASSWORD=Lrsh77635918@
MT5_SERVER=ForexTimeFXTM-Demo01

# å¤–éƒ¨APIé…ç½®  
HY_TOKEN=8tE8bq6InCxff5mUqQZfc9aGHP6NPD80Cr/k258SiLJ9CYW8HiMzU5pREYyvnbvjH4EUnzujYJ0K0brJdv8H4kWeABPgt+FOMgL80t65/UN0xEiqPIFgof8DNQijBcPGZCCgXJHLkOx5hlVr34QW6OxDKoODKKWeHDLHixm1c2AOuN9cCf60jxZD19TB0bhfKI7w0n7ZJilYpk/dvVsErvcW7MCFyrXdd7rfPLHxQPLt4U6UDSwF9cX0KvF1a1RXjHJ9D3BSZ/8B/s83ESyrRHZIQaiLaFNbW60UukOPqQOifOLfTEwYroo8i2GTzCFDqa1UNpxc+zprsehkVifoUcZcgYo95v85Arq8eSlHDqbIV0IxJ15oADYJZ8zgi5GoCw44Hy5h/tBBtt7OsiGYXR6d8mM5BAfdYSLYpGAPOAtCG9Wt+dgHlvvCZVOePGQC0g97SlpW+G+5N2qZGOXHr/3ob4GTtOG6Bj4pPb3hsBXQP3sEwxSNcEDCCYHVT+s3XehMc2l4I55waO15EFnLHq3i0cr6UHwxQXCyKLwTueYBfUK1HXstY0ViDWk0Hn12fAMCAL+nrAnmoJpE6YxunFp+I1i2+0ohyixd6vR4xEBb/KeeZe0A2U8zW5eEV2wVR6SUIln1a543rbthcXK33bIxxIPbb2LmsNqVlyGINNs=
HY_USER=7d5131e519874aee886b3492417b4428

# é‚®ä»¶é…ç½®ï¼ˆå¦‚æœéœ€è¦ï¼‰
EMAIL_PASSWORD=your_email_app_password

# Telegramé…ç½®ï¼ˆå¦‚æœéœ€è¦ï¼‰
TELEGRAM_BOT_TOKEN=your_telegram_bot_token
TELEGRAM_CHAT_ID=your_chat_id
"""
ç»çºªå•†é€‚é…å™¨æ¨¡å— - å¢å¼ºå¼‚å¸¸å¤„ç†ç‰ˆæœ¬
å®ç°ä¸MT5ç­‰ç»çºªå•†çš„è¿æ¥å’Œäº¤æ˜“æ“ä½œ
"""
import MetaTrader5 as mt5
import pandas as pd
from typing import Dict, List, Optional, Tuple, Any
from datetime import datetime
import time
from mt5_connection_manager import connection_manager

from interfaces import IBrokerAdapter
from logger import logger, log_execution_time
from exceptions.exception_handler import handle_exceptions, handle_specific_exceptions
from exceptions.trading_exceptions import (
    BrokerException, 
    MT5ConnectionException, 
    OrderExecutionException,
    ValidationException
)

class MT5BrokerAdapter(IBrokerAdapter):
    """MT5ç»çºªå•†é€‚é…å™¨ - å¢å¼ºå¼‚å¸¸å¤„ç†"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.connected = False
        self.connection_attempts = 0
        self.max_connection_attempts = 5
        self.last_connection_time = 0
        self.connection_cooldown = 60  # è¿æ¥å†·å´æ—¶é—´ï¼ˆç§’ï¼‰
        
        # ç»Ÿè®¡ä¿¡æ¯
        self.stats = {
            'connection_attempts': 0,
            'successful_connections': 0,
            'failed_connections': 0,
            'orders_placed': 0,
            'order_failures': 0,
            'last_error': None
        }
    
    @handle_exceptions(default_return=False, log_level="ERROR")
    @log_execution_time
    def connect(self) -> bool:
        """è¿æ¥åˆ°MT5 - ä½¿ç”¨è¿æ¥ç®¡ç†å™¨"""
        if self.connected:
            logger.info("å·²ç»è¿æ¥åˆ°MT5")
            return True
    
        try:
            account = self.config.get('mt5_account')
            password = self.config.get('mt5_password')
            server = self.config.get('mt5_server')
        
            # ä½¿ç”¨è¿æ¥ç®¡ç†å™¨
            connected = connection_manager.connect(account, password, server)
        
            if connected:
                self.connected = True
                self.stats['successful_connections'] += 1
            
                # è·å–è´¦æˆ·ä¿¡æ¯è®°å½•æ—¥å¿—
                account_info = mt5.account_info()
                logger.info(
                    f"ç»çºªå•†é€‚é…å™¨è¿æ¥æˆåŠŸ: {account_info.login}",
                    extra_data={
                        'account': account_info.login,
                        'balance': account_info.balance,
                       'server': account_info.server
                    }
                )
                return True
            else:
                self.stats['failed_connections'] += 1
                raise MT5ConnectionException("MT5è¿æ¥ç®¡ç†å™¨è¿æ¥å¤±è´¥")
            
        except MT5ConnectionException:
            raise
        except Exception as e:
            self.stats['failed_connections'] += 1
            self.stats['last_error'] = str(e)
            logger.error(f"è¿æ¥MT5å¼‚å¸¸: {str(e)}", exc_info=True)
            raise MT5ConnectionException(f"è¿æ¥MT5å¼‚å¸¸: {str(e)}", original_exception=e)
    
    @handle_exceptions(default_return=False, log_level="ERROR")
    @log_execution_time
    def disconnect(self) -> bool:
        """æ–­å¼€MT5è¿æ¥ - ä½¿ç”¨è¿æ¥ç®¡ç†å™¨"""
        if self.connected:
            # ä½¿ç”¨è¿æ¥ç®¡ç†å™¨æ–­å¼€ï¼ˆéå¼ºåˆ¶ï¼Œåªå‡å°‘å¼•ç”¨è®¡æ•°ï¼‰
            connection_manager.disconnect(force=False)
            self.connected = False
            logger.info("ç»çºªå•†é€‚é…å™¨å·²æ–­å¼€MT5è¿æ¥")
        return True
    
    @handle_exceptions(default_return=False, log_level="WARNING")
    def is_market_open(self, symbol: str = "XAUUSD") -> bool:
        """æ£€æŸ¥å¸‚åœºæ˜¯å¦å¼€ç›˜"""
        try:
            # è·å–å½“å‰æ—¶é—´
            now = datetime.now()
            weekday = now.weekday()  # 0=å‘¨ä¸€, 6=å‘¨æ—¥
        
            # å‘¨æœ«å¸‚åœºå…³é—­
            if weekday >= 5:  # 5=å‘¨å…­, 6=å‘¨æ—¥
                logger.info(f"å‘¨æœ«å¸‚åœºä¼‘å¸‚: {symbol}")
                return False
        
            # è·å–å½“å‰æ—¶é—´ï¼ˆUTCï¼‰
            utc_now = datetime.utcnow()
            utc_hour = utc_now.hour
        
            # æ£€æŸ¥äº¤æ˜“æ—¶é—´ï¼ˆUTCæ—¶é—´ï¼‰
            # å¤–æ±‡å¸‚åœºé€šå¸¸å‘¨æ—¥22:00 UTCå¼€ç›˜ï¼Œå‘¨äº”22:00 UTCæ”¶ç›˜
            if weekday == 6 and utc_hour < 22:  # å‘¨æ—¥22:00å‰
                logger.info(f"å‘¨æ—¥å¸‚åœºä¼‘å¸‚: {symbol}")
                return False
            if weekday == 4 and utc_hour >= 22:  # å‘¨äº”22:00å
                logger.info(f"å‘¨äº”å¸‚åœºä¼‘å¸‚: {symbol}")
                return False
        
            # è·å–å“ç§ä¿¡æ¯æ£€æŸ¥äº¤æ˜“æ—¶é—´
            symbol_info = mt5.symbol_info(symbol)
            if symbol_info is None:
                logger.warning(f"æ— æ³•è·å–å“ç§ä¿¡æ¯: {symbol}")
                return False
        
            # æ£€æŸ¥äº¤æ˜“æ¨¡å¼
            if symbol_info.trade_mode != mt5.SYMBOL_TRADE_MODE_FULL:
                logger.warning(f"å“ç§ {symbol} äº¤æ˜“æ¨¡å¼å—é™: {symbol_info.trade_mode}")
                return False
        
            return True
        
        except Exception as e:
            logger.error(
                f"æ£€æŸ¥å¸‚åœºçŠ¶æ€å¼‚å¸¸: {str(e)}",
                extra_data={'symbol': symbol}
            )
            return False

    @handle_exceptions(default_return={'success': False, 'error': 'è®¢å•æ‰§è¡Œå¼‚å¸¸'}, log_level="ERROR")
    @log_execution_time
    def place_order(self, order_params: Dict[str, Any]) -> Dict[str, Any]:
        """ä¸‹å•"""
        symbol = order_params.get('symbol', 'XAUUSD')
        self.stats['orders_placed'] += 1
    
        try:
            # æ£€æŸ¥å¸‚åœºæ˜¯å¦å¼€ç›˜
            if not self.is_market_open(symbol):
                error_msg = f'å¸‚åœºä¼‘å¸‚ï¼Œæ— æ³•äº¤æ˜“ {symbol}'
                logger.warning(error_msg)
                return {
                    'success': False, 
                    'error': error_msg,
                    'retcode': 'MARKET_CLOSED'
                }
    
            # æ£€æŸ¥è¿æ¥çŠ¶æ€
            if not self.connected and not self.connect():
                error_msg = 'MT5è¿æ¥å¤±è´¥'
                logger.error(error_msg)
                return {'success': False, 'error': error_msg}
    
            # å‡†å¤‡è®¢å•è¯·æ±‚
            request = self._prepare_order_request(order_params)
            if not request:
                error_msg = 'è®¢å•è¯·æ±‚å‡†å¤‡å¤±è´¥'
                logger.error(error_msg)
                return {'success': False, 'error': error_msg}
        
            # å‘é€è®¢å•
            result = mt5.order_send(request)
        
            if result is None:
                error_msg = 'è®¢å•å‘é€è¿”å›None'
                self.stats['order_failures'] += 1
                logger.error(error_msg)
                return {'success': False, 'error': error_msg}
        
            # ä½¿ç”¨æ•°å€¼æ£€æŸ¥è€Œä¸æ˜¯å¸¸é‡ï¼ˆé¿å…å¸¸é‡ä¸å­˜åœ¨çš„é—®é¢˜ï¼‰
            if result.retcode == 0:  # TRADE_RETCODE_DONE
                # è®¢å•æˆåŠŸ
                order_result = {
                    'success': True,
                    'order_id': result.order,
                    'ticket': result.deal,
                    'price': result.price,
                    'volume': result.volume,
                    'commission': result.commission,
                    'profit': result.profit,
                    'comment': result.comment
                }
            
                logger.info(
                    f"è®¢å•æ‰§è¡ŒæˆåŠŸ: {symbol}",
                    extra_data={
                        'symbol': symbol,
                        'order_id': result.order,
                        'direction': order_params.get('order_type'),
                        'volume': result.volume,
                        'price': result.price
                    }
                )
                return order_result
            else:
                # è®¢å•å¤±è´¥
                error_msg = self._get_error_description(result.retcode)
                self.stats['order_failures'] += 1
                self.stats['last_error'] = error_msg
                
                logger.error(
                    f"è®¢å•æ‰§è¡Œå¤±è´¥: {symbol}",
                    extra_data={
                        'symbol': symbol,
                        'order_type': order_params.get('order_type'),
                        'volume': order_params.get('volume'),
                        'retcode': result.retcode,
                        'error_msg': error_msg
                    }
                )
                
                raise OrderExecutionException(
                    order_params=order_params,
                    broker_error=error_msg,
                    context={'retcode': result.retcode}
                )
        
        except OrderExecutionException:
            # å·²ç»å¤„ç†è¿‡ï¼Œç›´æ¥é‡æ–°æŠ›å‡º
            raise
        except Exception as e:
            self.stats['order_failures'] += 1
            self.stats['last_error'] = str(e)
            
            logger.error(
                f"ä¸‹å•å¼‚å¸¸: {str(e)}",
                extra_data={
                    'symbol': symbol,
                    'order_params': order_params
                },
                exc_info=True
            )
            
            raise OrderExecutionException(
                order_params=order_params,
                broker_error=str(e),
                original_exception=e
            )
    
    @handle_exceptions(default_return=None, log_level="ERROR")
    def _prepare_order_request(self, order_params: Dict[str, Any]) -> Optional[Dict]:
        """å‡†å¤‡è®¢å•è¯·æ±‚"""
        try:
            symbol = order_params.get('symbol', 'XAUUSD')
            order_type = order_params.get('order_type')
            volume = order_params.get('volume', 0.01)
            price = order_params.get('price', 0.0)  
            stop_loss = order_params.get('stop_loss', 0.0)
            take_profit = order_params.get('take_profit', 0.0)  
            comment = order_params.get('comment', '')
            magic = order_params.get('magic', 0)
            
            # éªŒè¯è®¢å•å‚æ•°
            if volume <= 0 or price <= 0:
                logger.error(
                    "æ— æ•ˆçš„è®¢å•å‚æ•°: volumeæˆ–priceä¸º0",
                    extra_data={'order_params': order_params}
                )
                return None
            
            # ç¡®å®šè®¢å•ç±»å‹
            if order_type == 'buy':
                action = mt5.TRADE_ACTION_DEAL
                type_val = mt5.ORDER_TYPE_BUY
            elif order_type == 'sell':
                action = mt5.TRADE_ACTION_DEAL
                type_val = mt5.ORDER_TYPE_SELL
            else:
                logger.error(
                    f"ä¸æ”¯æŒçš„è®¢å•ç±»å‹: {order_type}",
                    extra_data={'order_params': order_params}
                )
                return None
            
            # è·å–å½“å‰ä»·æ ¼
            symbol_info = mt5.symbol_info(symbol)
            if symbol_info is None:
                logger.error(f"æ— æ³•è·å–å“ç§ä¿¡æ¯: {symbol}")
                return None
            
            # è®¡ç®—æ»‘ç‚¹
            deviation = self._calculate_deviation(symbol)
            
            # ç¡®å®šå¡«å……æ¨¡å¼
            filling_mode = self._get_filling_mode(symbol)
            
            request = {
                "action": action,
                "symbol": symbol,
                "volume": volume,
                "type": type_val,
                "price": price,
                "sl": stop_loss,
                "tp": take_profit,
                "deviation": deviation,
                "magic": magic,
                "comment": comment,
                "type_time": mt5.ORDER_TIME_GTC,
                "type_filling": filling_mode,
            }
            
            logger.debug(
                f"å‡†å¤‡è®¢å•è¯·æ±‚: {symbol}",
                extra_data={
                    'symbol': symbol,
                    'order_type': order_type,
                    'volume': volume,
                    'price': price
                }
            )
            
            return request
            
        except Exception as e:
            logger.error(
                f"å‡†å¤‡è®¢å•è¯·æ±‚å¼‚å¸¸: {str(e)}",
                extra_data={'order_params': order_params}
            )
            return None
    
    def _calculate_deviation(self, symbol: str) -> int:
        """è®¡ç®—å…è®¸çš„æ»‘ç‚¹"""
        # ç®€åŒ–å¤„ç†ï¼šå›ºå®šæ»‘ç‚¹
        return 20  # 20ç‚¹æ»‘ç‚¹
    
    def _get_filling_mode(self, symbol: str) -> int:
        """è·å–å¡«å……æ¨¡å¼"""
        # æ£€æŸ¥ç»çºªå•†æ”¯æŒçš„å¡«å……æ¨¡å¼
        symbol_info = mt5.symbol_info(symbol)
        if symbol_info is None:
            return mt5.ORDER_FILLING_RETURN
        
        # å°è¯•ä¸åŒçš„å¡«å……æ¨¡å¼
        if symbol_info.filling_mode == mt5.ORDER_FILLING_FOK:
            return mt5.ORDER_FILLING_FOK
        elif symbol_info.filling_mode == mt5.ORDER_FILLING_IOC:
            return mt5.ORDER_FILLING_IOC
        else:
            return mt5.ORDER_FILLING_RETURN
    
    @handle_exceptions(default_return=[], log_level="ERROR")
    @log_execution_time
    def get_positions(self, symbol: Optional[str] = None) -> List[Dict[str, Any]]:
        """è·å–æŒä»“"""
        if not self.connected and not self.connect():
            return []
        
        try:
            if symbol:
                positions = mt5.positions_get(symbol=symbol)
            else:
                positions = mt5.positions_get()
            
            if positions is None:
                logger.warning("æ²¡æœ‰æŒä»“æˆ–è·å–æŒä»“å¤±è´¥")
                return []
            
            positions_list = []
            for position in positions:
                position_dict = {
                    'ticket': position.ticket,
                    'symbol': position.symbol,
                    'type': 'buy' if position.type == mt5.ORDER_TYPE_BUY else 'sell',
                    'volume': position.volume,
                    'entry_price': position.price_open,
                    'current_price': position.price_current,
                    'stop_loss': position.sl,  
                    'take_profit': position.tp,
                    'profit': position.profit,
                    'swap': position.swap,
                    'commission': position.commission,
                    'magic': position.magic,
                    'comment': position.comment,
                    'time': datetime.fromtimestamp(position.time),
                    'time_update': datetime.fromtimestamp(position.time_update)
                }
                positions_list.append(position_dict)
            
            logger.debug(
                f"è·å–æŒä»“ä¿¡æ¯: {len(positions_list)} ä¸ªæŒä»“",
                extra_data={
                    'symbol': symbol,
                    'position_count': len(positions_list)
                }
            )
            
            return positions_list
            
        except Exception as e:
            logger.error(
                f"è·å–æŒä»“å¼‚å¸¸: {str(e)}",
                extra_data={'symbol': symbol}
            )
            return []
    
    @handle_exceptions(default_return=False, log_level="ERROR")
    @log_execution_time
    def close_position(self, position_id: str, reason: str = "") -> bool:
        """å¹³ä»“"""
        if not self.connected and not self.connect():
            return False
        
        try:
            # è·å–æŒä»“ä¿¡æ¯
            positions = mt5.positions_get(ticket=int(position_id))
            if not positions or len(positions) == 0:
                logger.error(f"æ‰¾ä¸åˆ°æŒä»“: {position_id}")
                return False
            
            position = positions[0]
            
            # å‡†å¤‡å¹³ä»“è¯·æ±‚
            if position.type == mt5.ORDER_TYPE_BUY:
                order_type = mt5.ORDER_TYPE_SELL
                price_type = mt5.ORDER_TYPE_SELL
            else:
                order_type = mt5.ORDER_TYPE_BUY
                price_type = mt5.ORDER_TYPE_BUY
            
            # è·å–å½“å‰ä»·æ ¼
            symbol_info = mt5.symbol_info(position.symbol)
            if symbol_info is None:
                logger.error(f"æ— æ³•è·å–å“ç§ä¿¡æ¯: {position.symbol}")
                return False
            
            price = symbol_info.ask if order_type == mt5.ORDER_TYPE_SELL else symbol_info.bid
            
            request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "position": position.ticket,
                "symbol": position.symbol,
                "volume": position.volume,
                "type": order_type,
                "price": price,
                "deviation": 20,
                "magic": position.magic,
                "comment": f"å¹³ä»“åŸå› : {reason}",
                "type_time": mt5.ORDER_TIME_GTC,
                "type_filling": self._get_filling_mode(position.symbol),
            }
            
            # å‘é€å¹³ä»“è¯·æ±‚
            result = mt5.order_send(request)
            
            if result is None:
                logger.error("å¹³ä»“è¯·æ±‚è¿”å›None")
                return False
            
            if result.retcode != mt5.TRADE_RETCODE_DONE:
                error_msg = self._get_error_description(result.retcode)
                logger.error(f"å¹³ä»“å¤±è´¥: {error_msg}")
                return False
            
            logger.info(
                f"å¹³ä»“æˆåŠŸ: æŒä»“{position_id}",
                extra_data={
                    'position_id': position_id,
                    'symbol': position.symbol,
                    'reason': reason,
                    'volume': position.volume
                }
            )
            return True
            
        except Exception as e:
            logger.error(
                f"å¹³ä»“å¼‚å¸¸: {str(e)}",
                extra_data={
                    'position_id': position_id,
                    'reason': reason
                }
            )
            return False
    
    def _get_error_description(self, retcode: int) -> str:
        """è·å–é”™è¯¯æè¿°"""
        error_descriptions = {
            0: "è¯·æ±‚å®Œæˆ",
            1: "è¯·æ±‚é”™è¯¯",
            2: "è¯·æ±‚æ— æ•ˆ",
            3: "è¯·æ±‚è¶…æ—¶",
            4: "è¯·æ±‚æ— æ•ˆ",
            5: "è¯·æ±‚é¢‘ç¹",
            6: "è¯·æ±‚è¢«ç¦æ­¢",
            7: "è¯·æ±‚è¢«æ‹’ç»",
            8: "è¯·æ±‚å–æ¶ˆ",
            9: "è¯·æ±‚æš‚åœ",
            10: "è¯·æ±‚æ— æ•ˆ",
            11: "è¯·æ±‚æ— æ•ˆ",
            12: "è¯·æ±‚æ— æ•ˆ",
            13: "è¯·æ±‚æ— æ•ˆ",
            14: "æ²¡æœ‰è¶³å¤Ÿçš„èµ„é‡‘",
            15: "ä»·æ ¼å·²å˜åŒ–",
            16: "ç»çºªå•†ç¹å¿™",
            17: "äº¤æ˜“è¢«ç¦æ­¢",
            18: "è®¢å•å·²å…³é—­",
            19: "è®¢å•å·²è¿‡æœŸ",
            20: "è®¢å•å·²å–æ¶ˆ",
            21: "æ— æ•ˆçš„è®¢å•",
            22: "æ— æ•ˆçš„äº¤æ˜“é‡",
            23: "æ— æ•ˆçš„ä»·æ ¼",
            24: "æ— æ•ˆçš„æ­¢æŸ",
            25: "æ— æ•ˆçš„æ­¢ç›ˆ",
            26: "æ— æ•ˆçš„è®¢å•å·",
            27: "äº¤æ˜“è¢«ç¦æ­¢",
            28: "äº¤æ˜“è¢«ç¦æ­¢",
            29: "äº¤æ˜“è¢«ç¦æ­¢",
            30: "äº¤æ˜“è¢«ç¦æ­¢",
            31: "äº¤æ˜“è¢«ç¦æ­¢",
            32: "äº¤æ˜“è¢«ç¦æ­¢",
            33: "äº¤æ˜“è¢«ç¦æ­¢",
            34: "äº¤æ˜“è¢«ç¦æ­¢",
            35: "äº¤æ˜“è¢«ç¦æ­¢",
            36: "äº¤æ˜“è¢«ç¦æ­¢",
            37: "äº¤æ˜“è¢«ç¦æ­¢",
            38: "äº¤æ˜“è¢«ç¦æ­¢",
            39: "äº¤æ˜“è¢«ç¦æ­¢",
            40: "äº¤æ˜“è¢«ç¦æ­¢",
            41: "äº¤æ˜“è¢«ç¦æ­¢",
            42: "äº¤æ˜“è¢«ç¦æ­¢",
            43: "äº¤æ˜“è¢«ç¦æ­¢",
            44: "äº¤æ˜“è¢«ç¦æ­¢",
            45: "äº¤æ˜“è¢«ç¦æ­¢",
            46: "äº¤æ˜“è¢«ç¦æ­¢",
            47: "äº¤æ˜“è¢«ç¦æ­¢",
            48: "äº¤æ˜“è¢«ç¦æ­¢",
            49: "äº¤æ˜“è¢«ç¦æ­¢",
            50: "äº¤æ˜“è¢«ç¦æ­¢",
        }
    
        return error_descriptions.get(retcode, f"æœªçŸ¥é”™è¯¯ç : {retcode}")
    
    @handle_exceptions(default_return={}, log_level="ERROR")
    def get_broker_stats(self) -> Dict[str, Any]:
        """è·å–ç»çºªå•†ç»Ÿè®¡ä¿¡æ¯"""
        stats = self.stats.copy()
        stats['connected'] = self.connected
        stats['connection_attempts_total'] = self.connection_attempts
        stats['current_time'] = datetime.now().isoformat()
        
        logger.debug(
            "è·å–ç»çºªå•†ç»Ÿè®¡ä¿¡æ¯",
            extra_data={'broker_stats': stats}
        )
        
        return stats
    
    def __del__(self):
        """ææ„å‡½æ•°ï¼Œç¡®ä¿æ–­å¼€è¿æ¥"""
        try:
            self.disconnect()
        except:
            pass
"""
æ¨¡æ‹Ÿç»çºªå•†é€‚é…å™¨ - ç”¨äºæµ‹è¯•
"""
from typing import Dict, List, Optional, Any
from datetime import datetime
from interfaces import IBrokerAdapter
from logger import logger

class MockBrokerAdapter(IBrokerAdapter):
    """æ¨¡æ‹Ÿç»çºªå•†é€‚é…å™¨ï¼Œç”¨äºæµ‹è¯•å’Œå¼€å‘"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.connected = True  # æ€»æ˜¯"å·²è¿æ¥"
        self.positions = []
        
    def connect(self) -> bool:
        """æ¨¡æ‹Ÿè¿æ¥"""
        logger.info("ğŸ”§ æ¨¡æ‹Ÿç»çºªå•†é€‚é…å™¨ - è¿æ¥æˆåŠŸï¼ˆæ¨¡æ‹Ÿæ¨¡å¼ï¼‰")
        return True
    
    def disconnect(self) -> bool:
        """æ¨¡æ‹Ÿæ–­å¼€è¿æ¥"""
        logger.info("ğŸ”§ æ¨¡æ‹Ÿç»çºªå•†é€‚é…å™¨ - æ–­å¼€è¿æ¥ï¼ˆæ¨¡æ‹Ÿæ¨¡å¼ï¼‰")
        return True
    
    def is_market_open(self, symbol: str = "XAUUSD") -> bool:
        """æ¨¡æ‹Ÿå¸‚åœºçŠ¶æ€æ£€æŸ¥"""
        # åœ¨æµ‹è¯•æ¨¡å¼ä¸­ï¼Œæ€»æ˜¯è¿”å›å¸‚åœºå¼€æ”¾
        return True
    
    def place_order(self, order_params: Dict[str, Any]) -> Dict[str, Any]:
        """æ¨¡æ‹Ÿä¸‹å•"""
        logger.info(f"ğŸ”§ æ¨¡æ‹Ÿä¸‹å•: {order_params}")
        
        # æ¨¡æ‹ŸæˆåŠŸä¸‹å•
        return {
            'success': True,
            'order_id': f"MOCK_{int(datetime.now().timestamp())}",
            'ticket': f"MOCK_{int(datetime.now().timestamp())}",
            'price': order_params.get('price', 1800.0),
            'volume': order_params.get('volume', 0.01),
            'commission': 0.0,
            'profit': 0.0,
            'comment': 'æ¨¡æ‹Ÿäº¤æ˜“'
        }
    
    def get_positions(self, symbol: Optional[str] = None) -> List[Dict[str, Any]]:
        """æ¨¡æ‹Ÿè·å–æŒä»“"""
        return self.positions
    
    def close_position(self, position_id: str, reason: str = "") -> bool:
        """æ¨¡æ‹Ÿå¹³ä»“"""
        logger.info(f"ğŸ”§ æ¨¡æ‹Ÿå¹³ä»“: {position_id}, åŸå› : {reason}")
        return True
"""
MT5è¿æ¥è®¾ç½®æ£€æŸ¥
"""
import sys
import os
sys.path.append(os.path.dirname(__file__))

def check_mt5_installation():
    """æ£€æŸ¥MT5å®‰è£…çŠ¶æ€"""
    print("ğŸ” æ£€æŸ¥MT5å®‰è£…çŠ¶æ€...")
    
    try:
        import MetaTrader5 as mt5
        print("âœ… MetaTrader5 PythonåŒ…å·²å®‰è£…")
        
        # æ£€æŸ¥MT5å¹³å°æ˜¯å¦è¿è¡Œ
        if mt5.initialize():
            print("âœ… MT5å¹³å°å·²è¿è¡Œ")
            mt5.shutdown()
            return True
        else:
            print("âŒ MT5å¹³å°æœªè¿è¡Œæˆ–æ— æ³•è¿æ¥")
            print("ğŸ’¡ è¯·ç¡®ä¿:")
            print("  1. MT5äº¤æ˜“å¹³å°æ­£åœ¨è¿è¡Œ")
            print("  2. å·²ç™»å½•äº¤æ˜“è´¦æˆ·")
            print("  3. å…è®¸è‡ªåŠ¨äº¤æ˜“")
            return False
            
    except ImportError:
        print("âŒ MetaTrader5 PythonåŒ…æœªå®‰è£…")
        print("ğŸ’¡ è¯·è¿è¡Œ: pip install MetaTrader5")
        return False

def check_test_mode_config():
    """æ£€æŸ¥æµ‹è¯•æ¨¡å¼é…ç½®"""
    print("\nğŸ”§ æ£€æŸ¥æµ‹è¯•æ¨¡å¼é…ç½®...")
    
    try:
        import yaml
        with open('config/production.yaml', 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)
        
        test_mode = config.get('trading', {}).get('test_mode', True)
        use_mt5 = config.get('trading', {}).get('use_mt5', False)
        
        print(f"âœ… å½“å‰é…ç½®: test_mode={test_mode}, use_mt5={use_mt5}")
        
        if test_mode:
            print("ğŸ’¡ ç³»ç»Ÿè¿è¡Œåœ¨æµ‹è¯•æ¨¡å¼ï¼Œä¸ä¼šè¿æ¥çœŸå®MT5")
            return True
        else:
            print("âš ï¸  ç³»ç»Ÿè¿è¡Œåœ¨çœŸå®äº¤æ˜“æ¨¡å¼ï¼Œéœ€è¦MT5è¿æ¥")
            return check_mt5_installation()
            
    except Exception as e:
        print(f"âŒ æ£€æŸ¥é…ç½®å¤±è´¥: {e}")
        return False

if __name__ == "__main__":
    print("ğŸš€ MT5è¿æ¥è®¾ç½®æ£€æŸ¥...\n")
    
    if check_test_mode_config():
        print("\nğŸ‰ MT5è®¾ç½®æ£€æŸ¥é€šè¿‡!")
    else:
        print("\nğŸ”§ è¯·æ ¹æ®ä¸Šè¿°æç¤ºä¿®å¤MT5è®¾ç½®")
"""
é…ç½®ç®¡ç†æ¨¡å—
è´Ÿè´£è¯»å–å’Œç®¡ç†ç³»ç»Ÿé…ç½®
"""
import yaml
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
import os

# å¯¼å…¥ç¯å¢ƒå˜é‡ç®¡ç†å™¨
from security.env_manager import env_manager

@dataclass
class TradingConfig:
    """äº¤æ˜“é…ç½®ç±»"""
    # é£é™©æ§åˆ¶å‚æ•°
    max_daily_risk: float = 0.03  # æ¯æ—¥æœ€å¤§é£é™©3%
    per_trade_risk: float = 0.01  # å•ç¬”äº¤æ˜“é£é™©1%
    max_drawdown: float = 0.05    # æœ€å¤§å›æ’¤5%
    min_confidence: float = 0.6   # æœ€ä½å¯ä¿¡åº¦é˜ˆå€¼60%
    min_win_rate: float = 0.4
    max_daily_trades: int = 10

    # äº¤æ˜“å‚æ•°
    symbols: List[str] = field(default_factory=lambda: ["XAUUSD"])
    timeframes: List[str] = field(default_factory=lambda: ["15m", "30m", "1h"])
    max_positions: int = 1        # æœ€å¤§æŒä»“æ•°é‡
    min_lot_size: float = 0.01    # æœ€å°äº¤æ˜“æ‰‹æ•°
    max_lot_size: float = 0.05     # æœ€å¤§äº¤æ˜“æ‰‹æ•°
    magic_number: int = 888666

    # MT5é…ç½® - ä»ç¯å¢ƒå˜é‡è·å–
    mt5_account: int = 0
    mt5_password: str = ""
    mt5_server: str = ""
    
    # APIé…ç½® - ä»ç¯å¢ƒå˜é‡è·å–
    base_url: str = "http://localhost:8000"
    hy_token: str = ""
    hy_user: str = ""
    agent_id: str = "naQivTmsDa"
    
    # é€šçŸ¥é…ç½®
    telegram_token: Optional[str] = None
    telegram_chat_id: Optional[str] = None

    # é‚®ä»¶é…ç½®
    email: Dict[str, Any] = field(default_factory=lambda: {
        'enabled': False,
        'smtp_server': 'smtp.gmail.com',
        'smtp_port': 587,
        'username': '',
        'password': '',  # ä»ç¯å¢ƒå˜é‡è·å–
        'to_address': ''
    })
    
    # æµ‹è¯•æ¨¡å¼
    test_mode: bool = False
    use_mt5: bool = True
    
    def __post_init__(self):
        """åˆå§‹åŒ–åå¤„ç† - ä»ç¯å¢ƒå˜é‡åŠ è½½æ•æ„Ÿä¿¡æ¯"""
        self._load_sensitive_data_from_env()
    
    def _load_sensitive_data_from_env(self):
        """ä»ç¯å¢ƒå˜é‡åŠ è½½æ•æ„Ÿæ•°æ®"""
        try:
            # åŠ è½½MT5é…ç½®
            mt5_config = env_manager.get_mt5_config()
            self.mt5_account = int(mt5_config['account'])
            self.mt5_password = mt5_config['password']
            self.mt5_server = mt5_config['server']
            
            # åŠ è½½HYé…ç½®
            hy_config = env_manager.get_hy_config()
            self.hy_token = hy_config['token']
            self.hy_user = hy_config['user']
            
            # åŠ è½½Telegramé…ç½®
            telegram_config = env_manager.get_telegram_config()
            self.telegram_token = telegram_config['token']
            self.telegram_chat_id = telegram_config['chat_id']
            
            # åŠ è½½é‚®ä»¶å¯†ç 
            if self.email.get('enabled', False):
                email_password = env_manager.get_optional('EMAIL_PASSWORD')
                if email_password:
                    self.email['password'] = email_password
            
        except Exception as e:
            raise ValueError(f"ä»ç¯å¢ƒå˜é‡åŠ è½½é…ç½®å¤±è´¥: {str(e)}")
    
    @classmethod
    def from_yaml(cls, file_path: str):
        """ä»YAMLæ–‡ä»¶åŠ è½½é…ç½®"""
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {file_path}")
        
        with open(file_path, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
        
        trading_config = data.get('trading', {})
        return cls(**trading_config)
    
    def to_dict(self) -> Dict[str, Any]:
        """å°†é…ç½®è½¬æ¢ä¸ºå­—å…¸ï¼ˆä¸åŒ…å«æ•æ„Ÿä¿¡æ¯ï¼‰"""
        # åˆ›å»ºä¸åŒ…å«æ•æ„Ÿä¿¡æ¯çš„é…ç½®å­—å…¸
        safe_config = {
            'max_daily_risk': self.max_daily_risk,
            'per_trade_risk': self.per_trade_risk,
            'max_drawdown': self.max_drawdown,
            'min_confidence': self.min_confidence,
            'min_win_rate': self.min_win_rate,
            'max_daily_trades': self.max_daily_trades,
            'symbols': self.symbols,
            'timeframes': self.timeframes,
            'max_positions': self.max_positions,
            'min_lot_size': self.min_lot_size,
            'max_lot_size': self.max_lot_size,
            'magic_number': self.magic_number,
            # æ•æ„Ÿä¿¡æ¯ç”¨å ä½ç¬¦æ›¿æ¢
            'mt5_account': '***',  # å®é™…å€¼ä»ç¯å¢ƒå˜é‡è·å–
            'mt5_password': '***',
            'mt5_server': '***',
            'base_url': self.base_url,
            'hy_token': '***',
            'hy_user': '***',
            'agent_id': self.agent_id,
            'telegram_token': '***' if self.telegram_token else None,
            'telegram_chat_id': '***' if self.telegram_chat_id else None,
            'email': {
                'enabled': self.email.get('enabled', False),
                'smtp_server': self.email.get('smtp_server', ''),
                'smtp_port': self.email.get('smtp_port', 587),
                'username': self.email.get('username', ''),
                'password': '***',  # å¯†ç ä¸æ˜¾ç¤º
                'to_address': self.email.get('to_address', '')
            },
            'test_mode': self.test_mode,
            'use_mt5': self.use_mt5
        }
        
        return safe_config

    def get_safe_log_dict(self) -> Dict[str, Any]:
        """è·å–å®‰å…¨çš„æ—¥å¿—é…ç½®å­—å…¸"""
        safe_dict = self.to_dict()
        # è¿›ä¸€æ­¥éšè—æ•æ„Ÿä¿¡æ¯
        safe_dict['mt5_account'] = f"{str(self.mt5_account)[:3]}***"
        return safe_dict

# é»˜è®¤é…ç½®ï¼ˆä¸åŒ…å«æ•æ„Ÿä¿¡æ¯ï¼‰
DEFAULT_CONFIG = {
    'trading': {
        'max_daily_risk': 0.03,
        'per_trade_risk': 0.01,
        'max_drawdown': 0.05,
        'min_confidence': 0.6,
        'min_win_rate': 0.4,
        'max_daily_trades': 10,
        'symbols': ['XAUUSD'],
        'timeframes': ['15m', '30m', '1h'],
        'max_positions': 1,
        'min_lot_size': 0.01,
        'max_lot_size': 0.05,
        'magic_number': 888666,
        # æ•æ„Ÿä¿¡æ¯ç”¨å ä½ç¬¦
        'mt5_account': 'ä»ç¯å¢ƒå˜é‡MT5_ACCOUNTè·å–',
        'mt5_password': 'ä»ç¯å¢ƒå˜é‡MT5_PASSWORDè·å–',
        'mt5_server': 'ä»ç¯å¢ƒå˜é‡MT5_SERVERè·å–',
        'base_url': 'http://localhost:8000',
        'hy_token': 'ä»ç¯å¢ƒå˜é‡HY_TOKENè·å–',
        'hy_user': 'ä»ç¯å¢ƒå˜é‡HY_USERè·å–',
        'agent_id': 'naQivTmsDa',
        'telegram_token': 'ä»ç¯å¢ƒå˜é‡TELEGRAM_BOT_TOKENè·å–',
        'telegram_chat_id': 'ä»ç¯å¢ƒå˜é‡TELEGRAM_CHAT_IDè·å–',
        'email': {
            'enabled': False,
            'smtp_server': 'smtp.gmail.com',
            'smtp_port': 587,
            'username': '',
            'password': 'ä»ç¯å¢ƒå˜é‡EMAIL_PASSWORDè·å–',
            'to_address': ''
        },
        'test_mode': False,
        'use_mt5': True
    }
}

def create_default_config(file_path: str):
    """åˆ›å»ºé»˜è®¤é…ç½®æ–‡ä»¶"""
    # ç¡®ä¿ç›®å½•å­˜åœ¨
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    
    with open(file_path, 'w', encoding='utf-8') as f:
        yaml.dump(DEFAULT_CONFIG, f, default_flow_style=False, allow_unicode=True, indent=2)
# create_config.py
from config import create_default_config

if __name__ == "__main__":
    create_default_config('config/production.yaml')
    print("âœ… é»˜è®¤é…ç½®æ–‡ä»¶å·²åˆ›å»º: config/production.yaml")
"""
æ•°æ®ç®¡ç†æ¨¡å— - å¢å¼ºå¼‚å¸¸å¤„ç†ç‰ˆæœ¬
"""
import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple, Any
import time
from datetime import datetime, timedelta
from collections import deque
import threading
from functools import lru_cache

from interfaces import IDataProvider
from logger import logger, log_execution_time
from data_providers.data_provider_factory import DataProviderFactory

# å¯¼å…¥å¼‚å¸¸å¤„ç†
from exceptions.trading_exceptions import (
    DataFetchException,
    InsufficientDataException,
    MT5ConnectionException
)
from exceptions.exception_handler import handle_exceptions, handle_specific_exceptions

class DataManager(IDataProvider):
    """æ•°æ®ç®¡ç†å™¨å®ç° - å¢å¼ºå¼‚å¸¸å¤„ç†"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.data_cache: Dict[str, Dict[str, deque]] = {}
        self.indicators_cache: Dict[str, Dict[str, Any]] = {}
        self.last_update_time: Dict[str, datetime] = {}
        self.cache_lock = threading.RLock()
        
        # ç»Ÿè®¡ä¿¡æ¯
        self.stats = {
            'data_requests': 0,
            'cache_hits': 0,
            'errors': 0,
            'last_error': None
        }
        
        # åˆ›å»ºæ•°æ®æä¾›è€…
        try:
            self.data_provider = DataProviderFactory.create_data_provider(config)
            logger.info(f"æ•°æ®ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ - ä½¿ç”¨ {self.data_provider.__class__.__name__}")
        except Exception as e:
            logger.error(f"æ•°æ®æä¾›è€…åˆ›å»ºå¤±è´¥: {str(e)}", exc_info=True)
            raise
        
        # åˆå§‹åŒ–æ•°æ®ç¼“å­˜
        for symbol in self.config.get('symbols', ['XAUUSD']):
            self.data_cache[symbol] = {}
            for timeframe in self.config.get('timeframes', ['15m', '30m', '1h']):
                self.data_cache[symbol][timeframe] = deque(maxlen=200)
    
    @handle_exceptions(default_return=pd.DataFrame(), log_level="ERROR")
    @log_execution_time
    def get_market_data(self, symbol: str, timeframe: str, count: int = 100) -> pd.DataFrame:
        """è·å–å¸‚åœºæ•°æ®"""
        # æ£€æŸ¥å‚æ•°æœ‰æ•ˆæ€§
        if not symbol or not timeframe:
            logger.warning(f"æ— æ•ˆçš„å‚æ•°: symbol={symbol}, timeframe={timeframe}")
            return pd.DataFrame()
    
        self.stats['data_requests'] += 1
        
        try:
            # æ·»åŠ æ•°é‡é™åˆ¶
            max_safe_count = 500  # å®‰å…¨é™åˆ¶
            if count > max_safe_count:
                logger.warning(f"è¯·æ±‚æ•°é‡ {count} è¶…è¿‡å®‰å…¨é™åˆ¶ï¼Œä½¿ç”¨ {max_safe_count}")
                count = max_safe_count

            # é¦–å…ˆæ£€æŸ¥ç¼“å­˜
            cached_data = self._get_cached_data(symbol, timeframe, count)
            if not cached_data.empty and self._is_cache_valid(symbol, timeframe):
                self.stats['cache_hits'] += 1
                logger.debug(f"ä½¿ç”¨ç¼“å­˜æ•°æ®: {symbol}{timeframe}")
                return cached_data
            
            # ä»æ•°æ®æä¾›è€…è·å–æ–°æ•°æ®
            logger.debug(f"ä»æ•°æ®æºè·å–æ•°æ®: {symbol}{timeframe}")
            data = self.data_provider.get_historical_data(symbol, timeframe, count)
            
            # éªŒè¯æ•°æ®
            if not self._validate_data(data, symbol, timeframe, count):
                logger.warning(f"æ•°æ®éªŒè¯å¤±è´¥: {symbol}{timeframe}")
                return cached_data  # è¿”å›ç¼“å­˜æ•°æ®ä½œä¸ºåå¤‡
            
            # ç¡®ä¿è¿”å›çš„æ˜¯DataFrame
            if isinstance(data, pd.DataFrame) and not data.empty:
                # æ›´æ–°ç¼“å­˜
                self._update_cache(symbol, timeframe, data)
                
                # æ·»åŠ symbolåˆ—ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
                if 'symbol' not in data.columns:
                    data['symbol'] = symbol
                    
                logger.info(
                    f"è·å–æ•°æ®æˆåŠŸ: {symbol}{timeframe}, {len(data)}æ¡è®°å½•",
                    extra_data={
                        'symbol': symbol,
                        'timeframe': timeframe,
                        'record_count': len(data),
                        'data_range': {
                            'start': data.index[0].isoformat() if not data.empty else None,
                            'end': data.index[-1].isoformat() if not data.empty else None
                        }
                    }
                )
                return data
            else:
                logger.warning(
                    f"è·å–çš„æ•°æ®æ— æ•ˆï¼Œä½¿ç”¨ç¼“å­˜æ•°æ®: {symbol}{timeframe}",
                    extra_data={'symbol': symbol, 'timeframe': timeframe}
                )
                return cached_data  # è¿”å›ç¼“å­˜æ•°æ®ä½œä¸ºåå¤‡
            
        except Exception as e:
            self.stats['errors'] += 1
            self.stats['last_error'] = str(e)
            
            # å¼‚å¸¸å·²ç»åœ¨è£…é¥°å™¨ä¸­å¤„ç†ï¼Œè¿™é‡Œè®°å½•é¢å¤–ä¸Šä¸‹æ–‡
            logger.error(
                f"è·å–å¸‚åœºæ•°æ®å¼‚å¸¸: {symbol}{timeframe}",
                extra_data={
                    'symbol': symbol,
                    'timeframe': timeframe,
                    'count': count,
                    'error': str(e)
                }
            )
            
            # è¿”å›ç¼“å­˜æ•°æ®ä½œä¸ºåå¤‡
            return self._get_cached_data(symbol, timeframe, count)
    
    # åœ¨ data_manager.py ä¸­æ”¹è¿› _validate_data æ–¹æ³•
    def _validate_data(self, data: pd.DataFrame, symbol: str, timeframe: str, expected_count: int) -> bool:
        """éªŒè¯æ•°æ®è´¨é‡ - æ›´å®½æ¾çš„éªŒè¯"""
        if data is None:
            logger.warning(f"æ•°æ®ä¸ºNone: {symbol}{timeframe}")
            return False
            
        if data.empty:
            logger.warning(f"æ•°æ®ä¸ºç©º: {symbol}{timeframe}")
            return False
    
        # æ›´å®½æ¾çš„æ•°æ®é‡æ£€æŸ¥ - åªè¦æœ‰æ•°æ®å°±æ¥å—
        min_required_count = max(1, expected_count // 10)  # è‡³å°‘æœŸæœ›çš„10%
        if len(data) < min_required_count:
            logger.warning(
                f"æ•°æ®é‡å¯èƒ½ä¸è¶³: {symbol}{timeframe}, æœŸæœ›è‡³å°‘ {min_required_count}, å®é™… {len(data)}",
                extra_data={
                    'symbol': symbol,
                    'timeframe': timeframe,
                    'expected_min_count': min_required_count,
                    'actual_count': len(data)
                }
            )
            # ä¸è¿”å›Falseï¼Œåªè¦æœ‰æ•°æ®å°±ç»§ç»­
    
        # æ£€æŸ¥å¿…éœ€åˆ—
        required_columns = ['open', 'high', 'low', 'close']
        missing_columns = [col for col in required_columns if col not in data.columns]
        if missing_columns:
            logger.error(
                f"æ•°æ®ç¼ºå°‘å¿…éœ€åˆ—: {symbol}{timeframe}, ç¼ºå¤±: {missing_columns}",
                extra_data={
                    'symbol': symbol,
                    'timeframe': timeframe,
                    'missing_columns': missing_columns,
                    'available_columns': list(data.columns)
               }
            )
            return False
    
        # æ£€æŸ¥æ•°æ®æœ‰æ•ˆæ€§ï¼ˆæ— NaNæˆ–æ— ç©·å¤§å€¼ï¼‰- æ›´å®½æ¾çš„æ£€æŸ¥
        numeric_columns = ['open', 'high', 'low', 'close']
        for col in numeric_columns:
            if col in data.columns:
                null_count = data[col].isnull().sum()
                if null_count > 0:
                    logger.warning(
                        f"æ•°æ®åŒ…å«ç©ºå€¼: {symbol}{timeframe}, åˆ— {col} æœ‰ {null_count} ä¸ªç©ºå€¼",
                        extra_data={
                            'symbol': symbol,
                            'timeframe': timeframe,
                            'column': col,
                            'null_count': null_count
                        }
                    )
                    # å¡«å……æˆ–åˆ é™¤ç©ºå€¼
                    data[col].fillna(method='ffill', inplace=True)
    
        # åŸºæœ¬ä»·æ ¼åˆç†æ€§æ£€æŸ¥
        if not data.empty:
            for col in numeric_columns:
                if data[col].min() <= 0:
                    logger.warning(
                        f"ä»·æ ¼æ•°æ®å¼‚å¸¸: {symbol}{timeframe}, åˆ— {col} æœ‰éæ­£å€¼",
                        extra_data={
                            'symbol': symbol,
                            'timeframe': timeframe,
                            'column': col,
                            'min_value': data[col].min()
                        }
                    )
    
        logger.debug(f"æ•°æ®éªŒè¯é€šè¿‡: {symbol}{timeframe}, {len(data)}æ¡è®°å½•")
        return True
    
    def _update_cache(self, symbol: str, timeframe: str, data: pd.DataFrame):
        """æ›´æ–°ç¼“å­˜"""
        with self.cache_lock:
            if symbol not in self.data_cache:
                self.data_cache[symbol] = {}
            if timeframe not in self.data_cache[symbol]:
                self.data_cache[symbol][timeframe] = deque(maxlen=200)
            
            # æ¸…ç©ºå½“å‰ç¼“å­˜å¹¶æ·»åŠ æ–°æ•°æ®
            self.data_cache[symbol][timeframe].clear()
            for _, row in data.iterrows():
                self.data_cache[symbol][timeframe].append(row.to_dict())
            
            # æ›´æ–°æœ€åæ›´æ–°æ—¶é—´
            cache_key = f"{symbol}_{timeframe}"
            self.last_update_time[cache_key] = datetime.now()
            
            logger.debug(
                f"ç¼“å­˜å·²æ›´æ–°: {symbol}{timeframe}",
                extra_data={
                    'symbol': symbol,
                    'timeframe': timeframe,
                    'cache_size': len(self.data_cache[symbol][timeframe])
                }
            )
    
    @handle_exceptions(default_return=pd.DataFrame())
    def _fetch_market_data(self, symbol: str, timeframe: str, count: int) -> pd.DataFrame:
        """è·å–å¸‚åœºæ•°æ®çš„å…·ä½“å®ç° - ç°åœ¨å§”æ‰˜ç»™æ•°æ®æä¾›è€…"""
        # è¿™ä¸ªæ–¹æ³•ç°åœ¨åªæ˜¯å‘åå…¼å®¹çš„åŒ…è£…å™¨
        return self.get_market_data(symbol, timeframe, count)
    
    def _is_cache_valid(self, symbol: str, timeframe: str) -> bool:
        """æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆ"""
        cache_key = f"{symbol}_{timeframe}"
        
        if cache_key not in self.last_update_time:
            return False
        
        # æ ¹æ®æ—¶é—´æ¡†æ¶ç¡®å®šç¼“å­˜æœ‰æ•ˆæœŸ
        cache_ttl = {
            '1m': timedelta(minutes=2),
            '5m': timedelta(minutes=6),
            '15m': timedelta(minutes=16),
            '30m': timedelta(minutes=31),
            '1h': timedelta(hours=1, minutes=5),
            'default': timedelta(minutes=16)
        }
        
        max_age = cache_ttl.get(timeframe, cache_ttl['default'])
        return datetime.now() - self.last_update_time[cache_key] < max_age
    
    def _get_cached_data(self, symbol: str, timeframe: str, count: int) -> pd.DataFrame:
        """è·å–ç¼“å­˜æ•°æ®"""
        with self.cache_lock:
            if (symbol in self.data_cache and 
                timeframe in self.data_cache[symbol] and 
                len(self.data_cache[symbol][timeframe]) > 0):
                
                data = list(self.data_cache[symbol][timeframe])
                if len(data) > count:
                    data = data[-count:]
                
                return pd.DataFrame(data)
            
            # å¦‚æœæ²¡æœ‰ç¼“å­˜æ•°æ®ï¼Œè¿”å›ç©ºDataFrame
            return pd.DataFrame(columns=['time', 'open', 'high', 'low', 'close', 'volume', 'symbol'])
    
    @handle_exceptions(default_return={})
    @log_execution_time
    def get_account_info(self) -> Dict[str, Any]:
        """è·å–è´¦æˆ·ä¿¡æ¯"""
        # è¿™é‡Œå¯ä»¥æ‰©å±•ä¸ºä»MT5è·å–çœŸå®è´¦æˆ·ä¿¡æ¯
        # ç›®å‰ä¿æŒæ¨¡æ‹Ÿæ•°æ®ä»¥ä¿æŒå…¼å®¹æ€§
        account_info = {
            'balance': 10000.0,
            'equity': 10250.0,
            'margin': 250.0,
            'free_margin': 9750.0,
            'leverage': 100,
            'currency': 'USD',
            'timestamp': datetime.now()
        }
        
        logger.debug(
            "è·å–è´¦æˆ·ä¿¡æ¯",
            extra_data={'account_info': account_info}
        )
        
        return account_info
    
    @handle_exceptions(default_return={})
    @log_execution_time
    def get_current_price(self, symbol: str) -> Dict[str, Any]:
        """è·å–å½“å‰ä»·æ ¼"""
        try:
            # ä»æ•°æ®æä¾›è€…è·å–å®æ—¶ä»·æ ¼
            current_data = self.data_provider.get_current_data(symbol)
            if current_data:
                logger.debug(
                    f"è·å–å½“å‰ä»·æ ¼æˆåŠŸ: {symbol}",
                    extra_data={
                        'symbol': symbol,
                        'bid': current_data.get('bid'),
                        'ask': current_data.get('ask'),
                        'spread': current_data.get('spread')
                    }
                )
                return current_data
            else:
                # åå¤‡æ–¹æ¡ˆï¼šä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®
                logger.warning(f"æ— æ³•è·å– {symbol} çš„å®æ—¶ä»·æ ¼ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®")
                return self._get_mock_current_price(symbol)
                
        except Exception as e:
            logger.error(
                f"è·å–å½“å‰ä»·æ ¼å¼‚å¸¸: {symbol}",
                extra_data={'symbol': symbol, 'error': str(e)}
            )
            return self._get_mock_current_price(symbol)
    
    def _get_mock_current_price(self, symbol: str) -> Dict[str, Any]:
        """è·å–æ¨¡æ‹Ÿå½“å‰ä»·æ ¼ï¼ˆåå¤‡æ–¹æ¡ˆï¼‰"""
        bid_price = 1800.0 + np.random.normal(0, 0.5)
        ask_price = bid_price + 0.1
        
        mock_data = {
            'symbol': symbol,
            'bid': bid_price,
            'ask': ask_price,
            'last': (bid_price + ask_price) / 2,
            'spread': ask_price - bid_price,
            'timestamp': datetime.now()
        }
        
        logger.debug(
            f"ä½¿ç”¨æ¨¡æ‹Ÿä»·æ ¼: {symbol}",
            extra_data={'mock_data': mock_data}
        )
        
        return mock_data
    
    @handle_exceptions(default_return={})
    @log_execution_time
    def calculate_technical_indicators(self, symbol: str, timeframe: str) -> Dict[str, Any]:
        """è®¡ç®—æŠ€æœ¯æŒ‡æ ‡"""
        try:
            data = self.get_market_data(symbol, timeframe, 100)
            
            if data.empty:
                logger.warning(
                    f"æ— æ³•è®¡ç®—æŠ€æœ¯æŒ‡æ ‡: {symbol}{timeframe} æ•°æ®ä¸ºç©º",
                    extra_data={'symbol': symbol, 'timeframe': timeframe}
                )
                return {}
            
            # è®¡ç®—å„ç§æŠ€æœ¯æŒ‡æ ‡
            indicators = self._calculate_all_indicators(data, symbol, timeframe)
            
            logger.debug(
                f"è®¡ç®—æŠ€æœ¯æŒ‡æ ‡å®Œæˆ: {symbol}{timeframe}",
                extra_data={
                    'symbol': symbol,
                    'timeframe': timeframe,
                    'indicators_count': len(indicators),
                    'key_indicators': {
                        'rsi': indicators.get('rsi'),
                        'macd': indicators.get('macd'),
                        'price': indicators.get('price')
                    }
                }
            )
            
            return indicators
            
        except Exception as e:
            logger.error(
                f"è®¡ç®—æŠ€æœ¯æŒ‡æ ‡å¼‚å¸¸: {symbol}{timeframe}",
                extra_data={
                    'symbol': symbol,
                    'timeframe': timeframe,
                    'error': str(e)
                },
                exc_info=True
            )
            return {}
    
    def _calculate_all_indicators(self, data: pd.DataFrame, symbol: str, timeframe: str) -> Dict[str, Any]:
        """è®¡ç®—æ‰€æœ‰æŠ€æœ¯æŒ‡æ ‡"""
        # è®¡ç®—RSI
        rsi = self._calculate_rsi(data['close'])
        
        # è®¡ç®—MACD
        macd, signal, histogram = self._calculate_macd(data['close'])
        
        # è®¡ç®—å¸ƒæ—å¸¦
        upper_bb, middle_bb, lower_bb = self._calculate_bollinger_bands(data['close'])
        
        # è®¡ç®—éšæœºæŒ‡æ ‡
        stoch_k, stoch_d = self._calculate_stochastic_oscillator(
            data['high'], data['low'], data['close']
        )
        
        # è®¡ç®—ç§»åŠ¨å¹³å‡çº¿
        sma_20 = self._calculate_sma(data['close'], 20)
        sma_50 = self._calculate_sma(data['close'], 50)
        sma_100 = self._calculate_sma(data['close'], 100)
        
        # è·å–å½“å‰ä»·æ ¼
        current_price_data = self.get_current_price(symbol)
        current_price = current_price_data.get('last', data['close'].iloc[-1] if not data.empty else 0)
        
        indicators = {
            'rsi': rsi,
            'macd': macd,
            'macd_signal': signal,
            'macd_histogram': histogram,
            'bb_upper': upper_bb,
            'bb_middle': middle_bb,
            'bb_lower': lower_bb,
            'stoch_k': stoch_k,
            'stoch_d': stoch_d,
            'sma_20': sma_20,
            'sma_50': sma_50,
            'sma_100': sma_100,
            'price': current_price,
            'timestamp': datetime.now(),
            'symbol': symbol,
            'timeframe': timeframe
        }
        
        return indicators
    
    # æŠ€æœ¯æŒ‡æ ‡è®¡ç®—æ–¹æ³•ä¿æŒä¸å˜...
    def _calculate_rsi(self, prices: pd.Series, period: int = 14) -> float:
        """è®¡ç®—RSI"""
        if len(prices) < period:
            return 50.0
        
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        
        if loss.iloc[-1] == 0:
            return 100.0 if gain.iloc[-1] > 0 else 50.0
        
        rs = gain.iloc[-1] / loss.iloc[-1]
        rsi = 100 - (100 / (1 + rs))
        
        return rsi
    
    def _calculate_macd(self, prices: pd.Series, 
                       fast_period: int = 12, 
                       slow_period: int = 26, 
                       signal_period: int = 9) -> Tuple[float, float, float]:
        """è®¡ç®—MACD"""
        if len(prices) < slow_period + signal_period:
            return 0.0, 0.0, 0.0
        
        exp1 = prices.ewm(span=fast_period, adjust=False).mean()
        exp2 = prices.ewm(span=slow_period, adjust=False).mean()
        macd_line = exp1 - exp2
        signal_line = macd_line.ewm(span=signal_period, adjust=False).mean()
        histogram = macd_line - signal_line
        
        return (
            macd_line.iloc[-1] if not macd_line.empty else 0.0,
            signal_line.iloc[-1] if not signal_line.empty else 0.0,
            histogram.iloc[-1] if not histogram.empty else 0.0
        )
    
    def _calculate_bollinger_bands(self, prices: pd.Series, 
                                  period: int = 20, 
                                  num_std: int = 2) -> Tuple[float, float, float]:
        """è®¡ç®—å¸ƒæ—å¸¦"""
        if len(prices) < period:
            return 0.0, 0.0, 0.0
        
        rolling_mean = prices.rolling(window=period).mean()
        rolling_std = prices.rolling(window=period).std()
        
        upper_band = rolling_mean.iloc[-1] + (rolling_std.iloc[-1] * num_std)
        middle_band = rolling_mean.iloc[-1]
        lower_band = rolling_mean.iloc[-1] - (rolling_std.iloc[-1] * num_std)
        
        return upper_band, middle_band, lower_band
    
    def _calculate_stochastic_oscillator(self, highs: pd.Series, lows: pd.Series, 
                                       closes: pd.Series, 
                                       k_period: int = 14, 
                                       d_period: int = 3) -> Tuple[float, float]:
        """è®¡ç®—éšæœºæŒ‡æ ‡"""
        if len(highs) < k_period or len(lows) < k_period or len(closes) < k_period:
            return 50.0, 50.0
        
        lowest_low = lows.rolling(window=k_period).min().iloc[-1]
        highest_high = highs.rolling(window=k_period).max().iloc[-1]
        
        if highest_high - lowest_low == 0:
            return 50.0, 50.0
        
        k = ((closes.iloc[-1] - lowest_low) / (highest_high - lowest_low)) * 100
        d = pd.Series([k]).rolling(window=d_period).mean().iloc[-1]
        
        return k, d
    
    def _calculate_sma(self, prices: pd.Series, period: int) -> float:
        """è®¡ç®—ç®€å•ç§»åŠ¨å¹³å‡çº¿"""
        if len(prices) < period:
            return 0.0
        
        return prices.rolling(window=period).mean().iloc[-1]
    
    @handle_exceptions(default_return={})
    def get_all_technical_indicators(self, symbol: str) -> Dict[str, Any]:
        """è·å–æ‰€æœ‰æ—¶é—´æ¡†æ¶çš„æŠ€æœ¯æŒ‡æ ‡"""
        indicators = {}
        
        for timeframe in self.config.get('timeframes', ['15m', '30m', '1h']):
            indicators[timeframe] = self.calculate_technical_indicators(symbol, timeframe)
        
        logger.debug(
            f"è·å–æ‰€æœ‰æ—¶é—´æ¡†æ¶æŒ‡æ ‡å®Œæˆ: {symbol}",
            extra_data={
                'symbol': symbol,
                'timeframes_count': len(indicators),
                'timeframes': list(indicators.keys())
            }
        )
        
        return indicators
    
    def clear_cache(self):
        """æ¸…ç©ºç¼“å­˜"""
        with self.cache_lock:
            self.data_cache.clear()
            self.indicators_cache.clear()
            self.last_update_time.clear()
            logger.info("æ•°æ®ç¼“å­˜å·²æ¸…ç©º")
    
    @handle_exceptions(default_return={})
    def get_cache_stats(self) -> Dict[str, Any]:
        """è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯"""
        stats = {
            'total_symbols': len(self.data_cache),
            'cache_entries': {},
            'last_update_times': {},
            'data_provider': self.data_provider.__class__.__name__,
            'performance_stats': self.stats.copy()
        }
        
        for symbol, timeframes in self.data_cache.items():
            stats['cache_entries'][symbol] = {}
            for timeframe, cache in timeframes.items():
                stats['cache_entries'][symbol][timeframe] = len(cache)
        
        for key, timestamp in self.last_update_time.items():
            stats['last_update_times'][key] = timestamp.strftime('%Y-%m-%d %H:%M:%S')
        
        logger.debug(
            "è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯",
            extra_data={'cache_stats': stats}
        )
        
        return stats
    
    def disconnect(self):
        """æ–­å¼€æ•°æ®æä¾›è€…è¿æ¥"""
        try:
            self.data_provider.disconnect()
            logger.info("æ•°æ®æä¾›è€…è¿æ¥å·²æ–­å¼€")
        except Exception as e:
            logger.error(
                f"æ–­å¼€æ•°æ®æä¾›è€…è¿æ¥å¼‚å¸¸: {str(e)}",
                extra_data={'error': str(e)}
            )
"""
è¯Šæ–­ç»çºªå•†é€‚é…å™¨è¿æ¥é—®é¢˜
"""
import sys
import os
sys.path.append(os.path.dirname(__file__))

import MetaTrader5 as mt5
from security.env_manager import env_manager
from broker_adapter import MT5BrokerAdapter

def diagnose_broker_connection():
    """è¯Šæ–­ç»çºªå•†è¿æ¥é—®é¢˜"""
    print("ğŸ” è¯Šæ–­ç»çºªå•†é€‚é…å™¨è¿æ¥é—®é¢˜...")
    
    # è·å–MT5é…ç½®
    mt5_config = env_manager.get_mt5_config()
    
    print(f"è´¦æˆ·: {mt5_config['account']}")
    print(f"æœåŠ¡å™¨: {mt5_config['server']}")
    print(f"å¯†ç : {'*' * len(mt5_config['password'])}")
    
    # æ–¹æ³•1: ç›´æ¥ä½¿ç”¨MT5è¿æ¥æµ‹è¯•
    print("\n1. ç›´æ¥MT5è¿æ¥æµ‹è¯•...")
    try:
        if not mt5.initialize():
            error = mt5.last_error()
            print(f"âŒ MT5åˆå§‹åŒ–å¤±è´¥: {error}")
            return False
        
        # å°è¯•ç™»å½•
        authorized = mt5.login(
            login=int(mt5_config['account']),
            password=mt5_config['password'],
            server=mt5_config['server']
        )
        
        if authorized:
            account_info = mt5.account_info()
            print(f"âœ… ç›´æ¥MT5ç™»å½•æˆåŠŸ!")
            print(f"   è´¦æˆ·: {account_info.login}")
            print(f"   ä½™é¢: ${account_info.balance}")
            print(f"   äº¤æ˜“æ¨¡å¼: {account_info.trade_mode}")
            print(f"   äº¤æ˜“å…è®¸: {account_info.trade_allowed}")
            
            # æ£€æŸ¥äº¤æ˜“æƒé™
            if account_info.trade_allowed:
                print("âœ… è´¦æˆ·å…è®¸äº¤æ˜“")
            else:
                print("âŒ è´¦æˆ·ä¸å…è®¸äº¤æ˜“ - è¿™å¯èƒ½æ˜¯é—®é¢˜æ‰€åœ¨!")
            
            mt5.shutdown()
            return True
        else:
            error = mt5.last_error()
            print(f"âŒ ç›´æ¥MT5ç™»å½•å¤±è´¥: {error}")
            
            # è¯¦ç»†é”™è¯¯åˆ†æ
            if error[0] == -2:
                print("ğŸ’¡ å…·ä½“é—®é¢˜: 'Invalid login argument'")
                print("   å¯èƒ½çš„åŸå› :")
                print("   - è´¦æˆ·å·æ ¼å¼é—®é¢˜")
                print("   - æœåŠ¡å™¨åç§°ä¸æ­£ç¡®")
                print("   - è´¦æˆ·å·²è¿‡æœŸæˆ–è¢«ç¦ç”¨")
            
            mt5.shutdown()
            return False
            
    except Exception as e:
        print(f"âŒ ç›´æ¥MT5æµ‹è¯•å¼‚å¸¸: {e}")
        return False

def test_broker_adapter():
    """æµ‹è¯•ç»çºªå•†é€‚é…å™¨"""
    print("\n2. æµ‹è¯•ç»çºªå•†é€‚é…å™¨...")
    
    try:
        config = {
            'mt5_account': int(env_manager.get_required('MT5_ACCOUNT')),
            'mt5_password': env_manager.get_required('MT5_PASSWORD'),
            'mt5_server': env_manager.get_required('MT5_SERVER')
        }
        
        broker = MT5BrokerAdapter(config)
        
        # æµ‹è¯•è¿æ¥
        if broker.connect():
            print("âœ… ç»çºªå•†é€‚é…å™¨è¿æ¥æˆåŠŸ")
            
            # æµ‹è¯•å¸‚åœºçŠ¶æ€
            market_open = broker.is_market_open('XAUUSD')
            print(f"âœ… å¸‚åœºçŠ¶æ€æ£€æŸ¥: {'å¼€æ”¾' if market_open else 'å…³é—­'}")
            
            broker.disconnect()
            return True
        else:
            print("âŒ ç»çºªå•†é€‚é…å™¨è¿æ¥å¤±è´¥")
            return False
            
    except Exception as e:
        print(f"âŒ ç»çºªå•†é€‚é…å™¨æµ‹è¯•å¼‚å¸¸: {e}")
        return False

def check_account_trading_permissions():
    """æ£€æŸ¥è´¦æˆ·äº¤æ˜“æƒé™"""
    print("\n3. æ£€æŸ¥è´¦æˆ·äº¤æ˜“æƒé™...")
    
    try:
        if not mt5.initialize():
            return False
        
        mt5_config = env_manager.get_mt5_config()
        authorized = mt5.login(
            login=int(mt5_config['account']),
            password=mt5_config['password'],
            server=mt5_config['server']
        )
        
        if not authorized:
            return False
        
        # æ£€æŸ¥è´¦æˆ·ä¿¡æ¯
        account_info = mt5.account_info()
        
        print(f"è´¦æˆ·ä¿¡æ¯:")
        print(f"  - ç™»å½•: {account_info.login}")
        print(f"  - äº¤æ˜“æ¨¡å¼: {account_info.trade_mode}")
        print(f"  - æ æ†: 1:{account_info.leverage}")
        print(f"  - ä½™é¢: ${account_info.balance}")
        print(f"  - å‡€å€¼: ${account_info.equity}")
        print(f"  - ä¿è¯é‡‘: ${account_info.margin}")
        print(f"  - å¯ç”¨ä¿è¯é‡‘: ${account_info.margin_free}")
        
        # æ£€æŸ¥å“ç§äº¤æ˜“æƒé™
        symbol = 'XAUUSD'
        symbol_info = mt5.symbol_info(symbol)
        if symbol_info:
            print(f"\nå“ç§ {symbol} ä¿¡æ¯:")
            print(f"  - äº¤æ˜“æ¨¡å¼: {symbol_info.trade_mode}")
            print(f"  - äº¤æ˜“å…è®¸: {symbol_info.trade_mode == 0}")  # 0 = SYMBOL_TRADE_MODE_FULL
            print(f"  - ç‚¹å·®: {symbol_info.spread}")
            print(f"  - åˆçº¦å¤§å°: {symbol_info.trade_contract_size}")
        else:
            print(f"âŒ æ— æ³•è·å–å“ç§ {symbol} ä¿¡æ¯")
        
        mt5.shutdown()
        return True
        
    except Exception as e:
        print(f"âŒ æƒé™æ£€æŸ¥å¼‚å¸¸: {e}")
        return False

def main():
    """ä¸»è¯Šæ–­å‡½æ•°"""
    print("ğŸš€ å¼€å§‹ç»çºªå•†è¿æ¥é—®é¢˜è¯Šæ–­...\n")
    
    tests = [
        diagnose_broker_connection,
        test_broker_adapter,
        check_account_trading_permissions
    ]
    
    results = []
    for test in tests:
        try:
            result = test()
            results.append(result)
            print("")  # ç©ºè¡Œåˆ†éš”
        except Exception as e:
            print(f"âŒ æµ‹è¯•å¼‚å¸¸: {e}")
            results.append(False)
    
    # æ±‡æ€»ç»“æœ
    print("="*60)
    print("ğŸ“‹ ç»çºªå•†è¿æ¥è¯Šæ–­ç»“æœ:")
    passed = sum(results)
    total = len(results)
    
    print(f"âœ… é€šè¿‡: {passed}/{total}")
    print(f"âŒ å¤±è´¥: {total - passed}/{total}")
    
    if passed == total:
        print("\nğŸ‰ ç»çºªå•†è¿æ¥è¯Šæ–­é€šè¿‡!")
        return True
    else:
        print("\nğŸ”§ å‘ç°é—®é¢˜ï¼Œå»ºè®®:")
        print("1. æ£€æŸ¥è´¦æˆ·äº¤æ˜“æƒé™")
        print("2. ç¡®è®¤æœåŠ¡å™¨åç§°æ­£ç¡®")
        print("3. éªŒè¯è´¦æˆ·æ˜¯å¦å…è®¸äº¤æ˜“")
        print("4. æ£€æŸ¥MT5å¹³å°æ˜¯å¦å·²ç™»å½•")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
"""
MT5è¿æ¥è¯Šæ–­è„šæœ¬
"""
import os
import MetaTrader5 as mt5
from security.env_manager import env_manager

def diagnose_mt5_connection():
    """è¯Šæ–­MT5è¿æ¥é—®é¢˜"""
    print("ğŸ” å¼€å§‹è¯Šæ–­MT5è¿æ¥é—®é¢˜...")
    
    # è·å–MT5é…ç½®
    mt5_config = env_manager.get_mt5_config()
    
    print(f"MT5è´¦æˆ·: {mt5_config['account']}")
    print(f"MT5æœåŠ¡å™¨: {mt5_config['server']}")
    print(f"MT5å¯†ç : {'*' * len(mt5_config['password'])}")
    
    # æ£€æŸ¥MT5å®‰è£…
    try:
        if not mt5.initialize():
            error = mt5.last_error()
            print(f"âŒ MT5åˆå§‹åŒ–å¤±è´¥: {error}")
            
            # å¸¸è§é”™è¯¯è¯Šæ–­
            if error[0] == -2:
                print("ğŸ’¡ å¯èƒ½çš„åŸå› :")
                print("  - MT5å¹³å°æœªå®‰è£…")
                print("  - MT5å¹³å°æœªè¿è¡Œ")
                print("  - è´¦æˆ·å·æ ¼å¼é”™è¯¯")
            return False
        else:
            print("âœ… MT5åˆå§‹åŒ–æˆåŠŸ")
    except Exception as e:
        print(f"âŒ MT5åˆå§‹åŒ–å¼‚å¸¸: {e}")
        print("ğŸ’¡ è¯·æ£€æŸ¥MetaTrader5åŒ…æ˜¯å¦å®‰è£…: pip install MetaTrader5")
        return False
    
    # å°è¯•ç™»å½•
    try:
        authorized = mt5.login(
            login=int(mt5_config['account']),
            password=mt5_config['password'],
            server=mt5_config['server']
        )
        
        if authorized:
            account_info = mt5.account_info()
            print(f"âœ… MT5ç™»å½•æˆåŠŸ!")
            print(f"   è´¦æˆ·: {account_info.login}")
            print(f"   ä½™é¢: ${account_info.balance}")
            print(f"   æœåŠ¡å™¨: {account_info.server}")
            mt5.shutdown()
            return True
        else:
            error = mt5.last_error()
            print(f"âŒ MT5ç™»å½•å¤±è´¥: {error}")
            
            # è¯¦ç»†é”™è¯¯åˆ†æ
            if error[0] == -2:
                print("ğŸ’¡ å…·ä½“é—®é¢˜: 'Invalid login argument'")
                print("   å¯èƒ½çš„åŸå› :")
                print("   - è´¦æˆ·å·åº”è¯¥æ˜¯æ•°å­—ï¼Œä½†åŒ…å«äº†éæ•°å­—å­—ç¬¦")
                print("   - æœåŠ¡å™¨åç§°ä¸æ­£ç¡®")
                print("   - è´¦æˆ·ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸ")
            elif error[0] == -1:
                print("ğŸ’¡ å…·ä½“é—®é¢˜: 'No connection to server'")
                print("   è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å’ŒæœåŠ¡å™¨çŠ¶æ€")
            
            mt5.shutdown()
            return False
            
    except ValueError as e:
        print(f"âŒ è´¦æˆ·å·æ ¼å¼é”™è¯¯: {e}")
        print(f"ğŸ’¡ è´¦æˆ·å· '{mt5_config['account']}' å¿…é¡»æ˜¯å¯ä»¥è½¬æ¢ä¸ºæ•´æ•°çš„æ•°å­—")
        return False
    except Exception as e:
        print(f"âŒ ç™»å½•è¿‡ç¨‹å¼‚å¸¸: {e}")
        mt5.shutdown()
        return False

if __name__ == "__main__":
    success = diagnose_mt5_connection()
    if success:
        print("\nğŸ‰ MT5è¿æ¥è¯Šæ–­é€šè¿‡!")
    else:
        print("\nğŸ”§ è¯·æ ¹æ®ä¸Šè¿°æç¤ºä¿®å¤MT5è¿æ¥é—®é¢˜")
# inspect_config.py
import yaml

def inspect_config_file():
    """æ£€æŸ¥é…ç½®æ–‡ä»¶ä¸­çš„æ‰€æœ‰é”®"""
    try:
        with open('config/production.yaml', 'r', encoding='utf-8') as f:
            config_data = yaml.safe_load(f)
        
        trading_config = config_data.get('trading', {})
        
        print("é…ç½®æ–‡ä»¶ä¸­çš„æ‰€æœ‰é…ç½®é¡¹:")
        for key, value in trading_config.items():
            print(f"  {key}: {value}")
            
        return trading_config.keys()
    except Exception as e:
        print(f"âŒ æ£€æŸ¥é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
        return []

if __name__ == "__main__":
    keys = inspect_config_file()
    print(f"\næ€»å…±æ‰¾åˆ° {len(keys)} ä¸ªé…ç½®é¡¹")
"""
æ ¸å¿ƒæ¥å£å®šä¹‰
å®šä¹‰ç³»ç»Ÿçš„æŠ½è±¡åŸºç±»å’Œæ¥å£
"""
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
import pandas as pd

class IDataProvider(ABC):
    """æ•°æ®æä¾›è€…æ¥å£"""
    
    @abstractmethod
    def get_market_data(self, symbol: str, timeframe: str, count: int = 100) -> pd.DataFrame:
        """è·å–å¸‚åœºæ•°æ®"""
        pass
    
    @abstractmethod
    def get_account_info(self) -> Dict[str, Any]:
        """è·å–è´¦æˆ·ä¿¡æ¯"""
        pass
    
    @abstractmethod
    def get_current_price(self, symbol: str) -> Dict[str, float]:
        """è·å–å½“å‰ä»·æ ¼"""
        pass

class ITradingStrategy(ABC):
    """äº¤æ˜“ç­–ç•¥æ¥å£"""
    
    @abstractmethod
    def generate_signal(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """ç”Ÿæˆäº¤æ˜“ä¿¡å·"""
        pass
    
    @abstractmethod
    def validate_signal(self, signal: Dict[str, Any]) -> bool:
        """éªŒè¯ä¿¡å·æœ‰æ•ˆæ€§"""
        pass

class IRiskManager(ABC):
    """é£é™©ç®¡ç†æ¥å£"""
    
    @abstractmethod
    def calculate_position_size(self, signal: Dict[str, Any], account_info: Dict[str, Any]) -> float:
        """è®¡ç®—ä»“ä½å¤§å°"""
        pass
    
    @abstractmethod
    def validate_trade(self, signal: Dict[str, Any], account_info: Dict[str, Any]) -> bool:
        """éªŒè¯äº¤æ˜“æ˜¯å¦ç¬¦åˆé£æ§è§„åˆ™"""
        pass
    
    @abstractmethod
    def update_risk_exposure(self, trade_result: Dict[str, Any]):
        """æ›´æ–°é£é™©æš´éœ²"""
        pass

class IBrokerAdapter(ABC):
    """ç»çºªå•†é€‚é…å™¨æ¥å£"""
    
    @abstractmethod
    def connect(self) -> bool:
        """è¿æ¥åˆ°ç»çºªå•†"""
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """æ–­å¼€è¿æ¥"""
        pass
    
    @abstractmethod
    def place_order(self, order_params: Dict[str, Any]) -> Dict[str, Any]:
        """ä¸‹å•"""
        pass
    
    @abstractmethod
    def get_positions(self, symbol: Optional[str] = None) -> List[Dict[str, Any]]:
        """è·å–æŒä»“"""
        pass
    
    @abstractmethod
    def close_position(self, position_id: str, reason: str = "") -> bool:
        """å¹³ä»“"""
        pass

class INotificationService(ABC):
    """é€šçŸ¥æœåŠ¡æ¥å£"""
    
    @abstractmethod
    def send_message(self, message: str, level: str = "info") -> bool:
        """å‘é€æ¶ˆæ¯"""
        pass
    
    @abstractmethod
    def send_trade_alert(self, trade_details: Dict[str, Any]) -> bool:
        """å‘é€äº¤æ˜“è­¦æŠ¥"""
        pass
    
    @abstractmethod
    def send_error_alert(self, error_message: str, context: Optional[Dict[str, Any]] = None) -> bool:
        """å‘é€é”™è¯¯è­¦æŠ¥"""
        pass
# logger.py
import logging
import sys
import os
from logging.handlers import RotatingFileHandler, TimedRotatingFileHandler
from typing import Dict, Any, Optional

# æ›´æ–°å¯¼å…¥è·¯å¾„ï¼šä» logging æ”¹ä¸º custom_logging
from custom_logging.formatters import TradingFormatter, JSONFormatter, ColoredFormatter
from custom_logging.filters import ModuleFilter, LevelRangeFilter, DuplicateFilter

def setup_logger(
    name: str, 
    log_file: str, 
    level: int = logging.INFO,
    max_bytes: int = 10 * 1024 * 1024,  # 10MB
    backup_count: int = 5,
    use_json: bool = False,
    use_color: bool = True
) -> logging.Logger:
    """
    è®¾ç½®æ—¥å¿—è®°å½•å™¨
    
    Args:
        name: æ—¥å¿—è®°å½•å™¨åç§°
        log_file: æ—¥å¿—æ–‡ä»¶è·¯å¾„
        level: æ—¥å¿—çº§åˆ«
        max_bytes: å•ä¸ªæ—¥å¿—æ–‡ä»¶æœ€å¤§å¤§å°
        backup_count: å¤‡ä»½æ–‡ä»¶æ•°é‡
        use_json: æ˜¯å¦ä½¿ç”¨JSONæ ¼å¼
        use_color: æ˜¯å¦ä½¿ç”¨å½©è‰²è¾“å‡º
    """
    # ç¡®ä¿æ—¥å¿—ç›®å½•å­˜åœ¨
    log_dir = os.path.dirname(log_file)
    if log_dir and not os.path.exists(log_dir):
        os.makedirs(log_dir, exist_ok=True)
    
    # åˆ›å»ºæ—¥å¿—è®°å½•å™¨
    logger = logging.getLogger(name)
    logger.setLevel(level)
    
    # é¿å…é‡å¤æ·»åŠ å¤„ç†å™¨
    if logger.handlers:
        return logger
    
    # é€‰æ‹©æ ¼å¼åŒ–å™¨
    if use_json:
        formatter = JSONFormatter()
    elif use_color and sys.stdout.isatty():
        formatter = ColoredFormatter()
    else:
        formatter = TradingFormatter()
    
    # åˆ›å»ºæ–‡ä»¶å¤„ç†å™¨ï¼ˆæŒ‰å¤§å°è½®è½¬ï¼‰
    file_handler = RotatingFileHandler(
        log_file, 
        maxBytes=max_bytes, 
        backupCount=backup_count,
        encoding='utf-8'
    )
    file_handler.setFormatter(formatter)
    
    # æ·»åŠ é‡å¤è¿‡æ»¤å™¨
    file_handler.addFilter(DuplicateFilter())
    
    # åˆ›å»ºæ§åˆ¶å°å¤„ç†å™¨
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    
    # æ·»åŠ æ¨¡å—è¿‡æ»¤å™¨ï¼ˆå¯é€‰ï¼‰
    # console_handler.addFilter(ModuleFilter(excluded_modules={'matplotlib', 'PIL'}))
    
    # æ·»åŠ å¤„ç†å™¨åˆ°è®°å½•å™¨
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    
    return logger

def setup_structured_logger(
    name: str,
    log_dir: str = "logs",
    level: int = logging.INFO
) -> logging.Logger:
    """
    è®¾ç½®ç»“æ„åŒ–æ—¥å¿—è®°å½•å™¨
    
    Args:
        name: æ—¥å¿—è®°å½•å™¨åç§°
        log_dir: æ—¥å¿—ç›®å½•
        level: æ—¥å¿—çº§åˆ«
    """
    # ç¡®ä¿æ—¥å¿—ç›®å½•å­˜åœ¨
    os.makedirs(log_dir, exist_ok=True)
    
    # ç»“æ„åŒ–æ—¥å¿—æ–‡ä»¶
    json_log_file = os.path.join(log_dir, f"{name}_structured.json")
    
    logger = logging.getLogger(f"{name}_structured")
    logger.setLevel(level)
    
    # é¿å…é‡å¤æ·»åŠ å¤„ç†å™¨
    if logger.handlers:
        return logger
    
    # JSONæ ¼å¼åŒ–å™¨
    json_formatter = JSONFormatter()
    
    # æ–‡ä»¶å¤„ç†å™¨ï¼ˆæŒ‰å¤©è½®è½¬ï¼‰
    file_handler = TimedRotatingFileHandler(
        json_log_file,
        when='midnight',
        interval=1,
        backupCount=30,
        encoding='utf-8'
    )
    file_handler.setFormatter(json_formatter)
    
    logger.addHandler(file_handler)
    
    return logger

class EnhancedTradingLogger:
    """å¢å¼ºçš„äº¤æ˜“ç³»ç»Ÿæ—¥å¿—å™¨"""
    
    def __init__(self, log_file: str = 'logs/trading.log', enable_structured_logging: bool = True):
        self.logger = setup_logger('trading_system', log_file)
        self.performance_logger = setup_logger('performance', 'logs/performance.log')
        self.error_logger = setup_logger('errors', 'logs/errors.log', logging.ERROR)
        
        # ç»“æ„åŒ–æ—¥å¿—è®°å½•å™¨
        if enable_structured_logging:
            self.structured_logger = setup_structured_logger('trading')
        else:
            self.structured_logger = None
        
        # ç»Ÿè®¡ä¿¡æ¯
        self.stats = {
            'info_count': 0,
            'warning_count': 0,
            'error_count': 0,
            'trade_events': 0
        }
    
    def info(self, message: str, extra_data: Optional[Dict[str, Any]] = None):
        """è®°å½•ä¿¡æ¯æ—¥å¿—"""
        self.stats['info_count'] += 1
        self.logger.info(message, extra={'extra_data': extra_data} if extra_data else {})
        
        # è®°å½•åˆ°ç»“æ„åŒ–æ—¥å¿—
        if self.structured_logger and extra_data:
            self._log_structured('INFO', message, extra_data)
    
    def warning(self, message: str, extra_data: Optional[Dict[str, Any]] = None):
        """è®°å½•è­¦å‘Šæ—¥å¿—"""
        self.stats['warning_count'] += 1
        self.logger.warning(message, extra={'extra_data': extra_data} if extra_data else {})
        
        if self.structured_logger and extra_data:
            self._log_structured('WARNING', message, extra_data)
    
    def error(self, message: str, exc_info: bool = False, extra_data: Optional[Dict[str, Any]] = None):
        """è®°å½•é”™è¯¯æ—¥å¿—"""
        self.stats['error_count'] += 1
        self.logger.error(message, exc_info=exc_info, extra={'extra_data': extra_data} if extra_data else {})
        self.error_logger.error(message, exc_info=exc_info, extra={'extra_data': extra_data} if extra_data else {})
        
        if self.structured_logger and extra_data:
            self._log_structured('ERROR', message, extra_data)
    
    def debug(self, message: str, extra_data: Optional[Dict[str, Any]] = None):
        """è®°å½•è°ƒè¯•æ—¥å¿—"""
        self.logger.debug(message, extra={'extra_data': extra_data} if extra_data else {})
        
        if self.structured_logger and extra_data:
            self._log_structured('DEBUG', message, extra_data)
    
    def performance(self, message: str, execution_time: Optional[float] = None, 
                   extra_data: Optional[Dict[str, Any]] = None):
        """è®°å½•æ€§èƒ½æ—¥å¿—"""
        if execution_time is not None:
            message = f"{message} - æ‰§è¡Œæ—¶é—´: {execution_time:.4f}ç§’"
        
        self.performance_logger.info(message, extra={'extra_data': extra_data} if extra_data else {})
        
        if self.structured_logger:
            perf_data = extra_data or {}
            if execution_time is not None:
                perf_data['execution_time'] = execution_time
            self._log_structured('INFO', message, perf_data, logger_name='performance')
    
    def trade_event(self, event_type: str, details: Dict[str, Any]):
        """è®°å½•äº¤æ˜“äº‹ä»¶"""
        self.stats['trade_events'] += 1
        message = f"TRADE_{event_type.upper()}: {details}"
        self.logger.info(message, extra={'extra_data': details})
        
        # è®°å½•åˆ°ç»“æ„åŒ–æ—¥å¿—
        if self.structured_logger:
            structured_data = {
                'event_type': event_type,
                'event_details': details,
                'category': 'trade_event'
            }
            self._log_structured('INFO', message, structured_data)
    
    def system_health(self, status: str, metrics: Dict[str, Any]):
        """è®°å½•ç³»ç»Ÿå¥åº·çŠ¶æ€"""
        message = f"SYSTEM_HEALTH: {status}"
        self.logger.info(message, extra={'extra_data': metrics})
        
        if self.structured_logger:
            health_data = {
                'status': status,
                'metrics': metrics,
                'category': 'system_health'
            }
            self._log_structured('INFO', message, health_data)
    
    def _log_structured(self, level: str, message: str, extra_data: Dict[str, Any], 
                       logger_name: str = 'trading'):
        """è®°å½•ç»“æ„åŒ–æ—¥å¿—"""
        if not self.structured_logger:
            return
        
        log_method = getattr(self.structured_logger, level.lower())
        log_data = {
            'message': message,
            **extra_data
        }
        
        # ä½¿ç”¨extraå‚æ•°ä¼ é€’ç»“æ„åŒ–æ•°æ®
        log_method(message, extra={'structured_data': log_data})
    
    def get_stats(self) -> Dict[str, Any]:
        """è·å–æ—¥å¿—ç»Ÿè®¡ä¿¡æ¯"""
        return self.stats.copy()
    
    def reset_stats(self):
        """é‡ç½®ç»Ÿè®¡ä¿¡æ¯"""
        self.stats = {
            'info_count': 0,
            'warning_count': 0,
            'error_count': 0,
            'trade_events': 0
        }

# å…¨å±€æ—¥å¿—å®ä¾‹
logger = EnhancedTradingLogger()

# è£…é¥°å™¨ç”¨äºè®°å½•å‡½æ•°æ‰§è¡Œæ—¶é—´
def log_execution_time(func):
    """è®°å½•å‡½æ•°æ‰§è¡Œæ—¶é—´çš„è£…é¥°å™¨"""
    import time
    from functools import wraps
    
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        
        logger.performance(
            f"{func.__module__}.{func.__name__} æ‰§è¡Œå®Œæˆ",
            execution_time=execution_time,
            extra_data={
                'module': func.__module__,
                'function': func.__name__,
                'execution_time': execution_time
            }
        )
        
        return result
    
    return wrapper

"""
ä¸»ç¨‹åºå…¥å£
äº¤æ˜“ç³»ç»Ÿçš„å¯åŠ¨å’Œé…ç½®ç®¡ç†
"""
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, Any

# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°Pythonè·¯å¾„
sys.path.append(str(Path(__file__).parent))

from trading_engine import TradingEngine
from logger import logger
# å¯¼å…¥ç¯å¢ƒç®¡ç†å™¨
from security.env_manager import env_manager

def load_config(config_path: str) -> Dict[str, Any]:
    """åŠ è½½é…ç½®æ–‡ä»¶"""
    import yaml
    
    if not os.path.exists(config_path):
        logger.error(f"é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {config_path}")
        sys.exit(1)
    
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)
        return config
    except Exception as e:
        logger.error(f"åŠ è½½é…ç½®æ–‡ä»¶å¤±è´¥: {str(e)}")
        sys.exit(1)

def create_default_config(config_path: str):
    """åˆ›å»ºé»˜è®¤é…ç½®æ–‡ä»¶"""
    import yaml
    
    default_config = {
        'trading': {
            'max_daily_risk': 0.03,
            'per_trade_risk': 0.01,
            'max_drawdown': 0.05,
            'min_confidence': 0.6,
            'min_win_rate': 0.4,
            'symbols': ['XAUUSD'],
            'timeframes': ['15m', '30m', '1h'],
            'max_positions': 1,
            'min_lot_size': 0.01,
            'max_lot_size': 0.05,
            'max_daily_trades': 10,
            'magic_number': 888666,
            
            # ä½¿ç”¨å ä½ç¬¦
            'mt5_account': 'ä»ç¯å¢ƒå˜é‡MT5_ACCOUNTè·å–',
            'mt5_password': 'ä»ç¯å¢ƒå˜é‡MT5_PASSWORDè·å–',
            'mt5_server': 'ä»ç¯å¢ƒå˜é‡MT5_SERVERè·å–',
            
            'base_url': 'http://localhost:8000',
            'hy_token': 'ä»ç¯å¢ƒå˜é‡HY_TOKENè·å–',
            'hy_user': 'ä»ç¯å¢ƒå˜é‡HY_USERè·å–',
            'agent_id': 'your_agent_id',
            
            'telegram_token': 'ä»ç¯å¢ƒå˜é‡TELEGRAM_BOT_TOKENè·å–',
            'telegram_chat_id': 'ä»ç¯å¢ƒå˜é‡TELEGRAM_CHAT_IDè·å–',
            
            'email': {
                'enabled': False,
                'smtp_server': 'smtp.gmail.com',
                'smtp_port': 587,
                'username': 'your_email@gmail.com',
                'password': 'ä»ç¯å¢ƒå˜é‡EMAIL_PASSWORDè·å–',
                'to_address': 'recipient@email.com'
            }
        }
    }
    
    # ç¡®ä¿é…ç½®ç›®å½•å­˜åœ¨
    os.makedirs(os.path.dirname(config_path), exist_ok=True)
    
    with open(config_path, 'w', encoding='utf-8') as f:
        yaml.dump(default_config, f, default_flow_style=False, allow_unicode=True, indent=2)
    
    logger.info(f"é»˜è®¤é…ç½®æ–‡ä»¶å·²åˆ›å»º: {config_path}")

def setup_logging(log_dir: str = "logs"):
    """è®¾ç½®æ—¥å¿—ç³»ç»Ÿ"""
    os.makedirs(log_dir, exist_ok=True)
    
    # æ—¥å¿—é…ç½®å·²ç»åœ¨loggeræ¨¡å—ä¸­å®Œæˆ
    logger.info("æ—¥å¿—ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ")

def main():
    """ä¸»å‡½æ•°"""
    parser = argparse.ArgumentParser(description='è‡ªåŠ¨åŒ–äº¤æ˜“ç³»ç»Ÿ')
    parser.add_argument('--config', '-c', default='config/production_safe.yaml', 
                       help='é…ç½®æ–‡ä»¶è·¯å¾„')
    parser.add_argument('--init', action='store_true', 
                       help='åˆ›å»ºé»˜è®¤é…ç½®æ–‡ä»¶')
    parser.add_argument('--test', action='store_true', 
                       help='æµ‹è¯•æ¨¡å¼ï¼Œä¸æ‰§è¡Œå®é™…äº¤æ˜“')
    parser.add_argument('--verbose', '-v', action='store_true', 
                       help='è¯¦ç»†æ—¥å¿—è¾“å‡º')
    
    args = parser.parse_args()
    
    # å¤„ç†åˆå§‹åŒ–å‘½ä»¤
    if args.init:
        create_default_config(args.config)
        logger.info("âœ… é»˜è®¤é…ç½®æ–‡ä»¶å·²åˆ›å»º")
        logger.info("ğŸ“ è¯·å¤åˆ¶ .env.example ä¸º .env å¹¶è®¾ç½®æ‚¨çš„æ•æ„Ÿä¿¡æ¯")
        return
    
    # éªŒè¯ç¯å¢ƒå˜é‡
    logger.info("ğŸ” éªŒè¯ç¯å¢ƒå˜é‡...")
    if not env_manager.validate_environment():
        logger.error("âŒ ç¯å¢ƒå˜é‡éªŒè¯å¤±è´¥ï¼Œè¯·è®¾ç½®å¿…éœ€çš„ç¯å¢ƒå˜é‡")
        logger.info("ğŸ’¡ è¯·æ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š")
        logger.info("1. å¤åˆ¶ .env.example ä¸º .env")
        logger.info("2. åœ¨ .env æ–‡ä»¶ä¸­è®¾ç½®æ‚¨çš„çœŸå®è´¦æˆ·ä¿¡æ¯")
        logger.info("3. é‡æ–°å¯åŠ¨ç³»ç»Ÿ")
        sys.exit(1)
    
    # åŠ è½½é…ç½®
    config = load_config(args.config)
    trading_config = config.get('trading', {})
    
    if args.test:
        trading_config['test_mode'] = True
        logger.info("æµ‹è¯•æ¨¡å¼å¯ç”¨ï¼Œä¸ä¼šæ‰§è¡Œå®é™…äº¤æ˜“")
    
    if args.verbose:
        # è®¾ç½®æ›´è¯¦ç»†çš„æ—¥å¿—çº§åˆ«
        import logging
        logging.getLogger().setLevel(logging.DEBUG)
        logger.info("è¯¦ç»†æ—¥å¿—æ¨¡å¼å¯ç”¨")
    
    # è®¾ç½®æ—¥å¿—
    setup_logging()
    
    # åˆ›å»ºå¹¶å¯åŠ¨äº¤æ˜“å¼•æ“
    try:
        engine = TradingEngine(trading_config)
        
        logger.info("ğŸš€ å¯åŠ¨äº¤æ˜“ç³»ç»Ÿ...")
        if engine.start():
            logger.info("âœ… äº¤æ˜“ç³»ç»Ÿæ­£å¸¸é€€å‡º")
        else:
            logger.error("âŒ äº¤æ˜“ç³»ç»Ÿå¯åŠ¨å¤±è´¥")
            sys.exit(1)
            
    except KeyboardInterrupt:
        logger.info("â¹ï¸ æ”¶åˆ°ä¸­æ–­ä¿¡å·ï¼Œå…³é—­ç³»ç»Ÿ")
    except Exception as e:
        logger.critical(f"ğŸ’¥ ç³»ç»Ÿè¿è¡Œå¼‚å¸¸: {str(e)}")
        sys.exit(1)
    
    logger.info("ğŸ›‘ äº¤æ˜“ç³»ç»Ÿå·²å…³é—­")

if __name__ == "__main__":
    main()
# æ¨¡å—å‘½åæŒ‡å—

## é—®é¢˜èƒŒæ™¯
Python æ ‡å‡†åº“åŒ…å«å¾ˆå¤šå¸¸ç”¨æ¨¡å—ï¼Œå¦‚ `logging`ã€`time`ã€`json` ç­‰ã€‚å¦‚æœæˆ‘ä»¬çš„è‡ªå®šä¹‰åŒ…ä½¿ç”¨ç›¸åŒåç§°ï¼Œä¼šå¯¼è‡´å‘½åå†²çªã€‚

## å‘½åè§„èŒƒ

### âœ… æ¨èçš„å‘½åæ–¹å¼
1. **æ·»åŠ å‰ç¼€**: `custom_`ã€`my_`ã€`app_`
   - `custom_logging` è€Œä¸æ˜¯ `logging`
   - `app_utils` è€Œä¸æ˜¯ `utils`

2. **ä½¿ç”¨é¡¹ç›®ç‰¹å®šå‰ç¼€**:
   - `trading_engine` 
   - `mt5_adapter`
   - `risk_manager`

3. **æè¿°æ€§åç§°**:
   - `data_providers` è€Œä¸æ˜¯ `data`
   - `notification_services` è€Œä¸æ˜¯ `notifications`

### âŒ é¿å…ä½¿ç”¨çš„åç§°
ä¸è¦ä½¿ç”¨è¿™äº›æ ‡å‡†åº“æ¨¡å—åä½œä¸ºåŒ…åï¼š
- `logging`
- `time` 
- `json`
- `os`
- `sys`
- `math`
- `random`
- `datetime`
- `collections`
- `threading`

## å½“å‰é¡¹ç›®æ¨¡å—ç»“æ„
"""
æ•°æ®è´¨é‡ç›‘æ§
"""
import sys
import os
sys.path.append(os.path.dirname(__file__))

import pandas as pd
from datetime import datetime, timedelta
from data_manager import DataManager
from security.env_manager import env_manager

def monitor_data_quality():
    """ç›‘æ§æ•°æ®è´¨é‡"""
    print("ğŸ“Š æ•°æ®è´¨é‡ç›‘æ§...")
    
    # è·å–MT5é…ç½®
    mt5_config = env_manager.get_mt5_config()
    config = {
        'mt5_account': int(mt5_config['account']),
        'mt5_password': mt5_config['password'],
        'mt5_server': mt5_config['server'],
        'symbols': ['XAUUSD'],
        'timeframes': ['15m', '30m', '1h'],
        'use_mt5': True,
        'test_mode': False
    }
    
    data_manager = DataManager(config)
    
    try:
        print("ğŸ” æ£€æŸ¥å„æ—¶é—´æ¡†æ¶æ•°æ®è´¨é‡...")
        
        timeframes = ['15m', '30m', '1h']
        for timeframe in timeframes:
            data = data_manager.get_market_data('XAUUSD', timeframe, 50)
            
            if not data.empty:
                print(f"\nâœ… {timeframe} æ•°æ®è´¨é‡:")
                print(f"   è®°å½•æ•°: {len(data)}")
                print(f"   æ—¶é—´èŒƒå›´: {data.index[0]} åˆ° {data.index[-1]}")
                print(f"   ä»·æ ¼èŒƒå›´: {data['low'].min():.2f} - {data['high'].max():.2f}")
                print(f"   æ³¢åŠ¨ç‡: {(data['high'].max() - data['low'].min()):.2f}")
                
                # æ£€æŸ¥æ•°æ®è¿ç»­æ€§
                time_diff = data.index.to_series().diff().dropna()
                avg_interval = time_diff.mean()
                print(f"   å¹³å‡é—´éš”: {avg_interval}")
                
                # æ£€æŸ¥ç¼ºå¤±å€¼
                missing_values = data.isnull().sum().sum()
                print(f"   ç¼ºå¤±å€¼: {missing_values}")
            else:
                print(f"âŒ {timeframe} æ•°æ®è·å–å¤±è´¥")
        
        # æ£€æŸ¥å½“å‰ä»·æ ¼
        current_price = data_manager.get_current_price('XAUUSD')
        if current_price:
            print(f"\nğŸ’° å½“å‰ä»·æ ¼:")
            print(f"   ä¹°ä»·: {current_price['bid']:.2f}")
            print(f"   å–ä»·: {current_price['ask']:.2f}")
            print(f"   ç‚¹å·®: {current_price['spread']:.4f}")
        
        data_manager.disconnect()
        return True
        
    except Exception as e:
        print(f"âŒ æ•°æ®è´¨é‡ç›‘æ§å¼‚å¸¸: {e}")
        return False

if __name__ == "__main__":
    success = monitor_data_quality()
    if success:
        print("\nğŸ‰ æ•°æ®è´¨é‡ç›‘æ§å®Œæˆ!")
    else:
        print("\nâš ï¸  æ•°æ®è´¨é‡ç›‘æ§å‘ç°é—®é¢˜")
"""
MT5è¿æ¥ç®¡ç†å™¨ - å•ä¾‹æ¨¡å¼ï¼Œé¿å…é‡å¤è¿æ¥
"""
import MetaTrader5 as mt5
import threading
from typing import Optional, Dict, Any
from logger import logger

class MT5ConnectionManager:
    """MT5è¿æ¥ç®¡ç†å™¨ï¼ˆå•ä¾‹ï¼‰"""
    
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        with cls._lock:
            if cls._instance is None:
                cls._instance = super().__new__(cls)
                cls._instance._initialized = False
            return cls._instance
    
    def __init__(self):
        if not self._initialized:
            self._lock = threading.Lock()
            self.connection_count = 0
            self.is_connected = False
            self.connection_params = None
            self._initialized = True
    
    def connect(self, account: int, password: str, server: str) -> bool:
        """è¿æ¥åˆ°MT5ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰"""
        with self._lock:
            if self.is_connected:
                self.connection_count += 1
                logger.debug(f"MT5è¿æ¥å·²å­˜åœ¨ï¼Œå¼•ç”¨è®¡æ•°: {self.connection_count}")
                return True
            
            try:
                logger.info(f"æ­£åœ¨åˆå§‹åŒ–MT5è¿æ¥...")
                
                # å…ˆå…³é—­ä»»ä½•ç°æœ‰è¿æ¥
                if mt5.initialize():
                    mt5.shutdown()
                
                # é‡æ–°åˆå§‹åŒ–
                if not mt5.initialize():
                    error = mt5.last_error()
                    logger.error(f"MT5åˆå§‹åŒ–å¤±è´¥: {error}")
                    return False
                
                # ç™»å½•è´¦æˆ·
                authorized = mt5.login(
                    login=account,
                    password=password,
                    server=server
                )
                
                if not authorized:
                    error = mt5.last_error()
                    logger.error(f"MT5ç™»å½•å¤±è´¥: {error}")
                    mt5.shutdown()
                    return False
                
                # éªŒè¯è¿æ¥
                account_info = mt5.account_info()
                if account_info is None:
                    logger.error("æ— æ³•è·å–è´¦æˆ·ä¿¡æ¯")
                    mt5.shutdown()
                    return False
                
                self.is_connected = True
                self.connection_count = 1
                self.connection_params = {
                    'account': account,
                    'server': server
                }
                
                logger.info(
                    f"MT5è¿æ¥æˆåŠŸ: è´¦æˆ· {account_info.login}, æœåŠ¡å™¨ {account_info.server}",
                    extra_data={
                        'account': account_info.login,
                        'balance': account_info.balance,
                        'server': account_info.server
                    }
                )
                return True
                
            except Exception as e:
                logger.error(f"MT5è¿æ¥å¼‚å¸¸: {str(e)}", exc_info=True)
                # ç¡®ä¿å…³é—­è¿æ¥
                try:
                    mt5.shutdown()
                except:
                    pass
                self.is_connected = False
                return False
    
    def disconnect(self, force: bool = False) -> bool:
        """æ–­å¼€MT5è¿æ¥"""
        with self._lock:
            if not self.is_connected:
                return True
            
            if not force:
                self.connection_count -= 1
                if self.connection_count > 0:
                    logger.debug(f"MT5è¿æ¥å¼•ç”¨è®¡æ•°å‡å°‘: {self.connection_count}")
                    return True
            
            try:
                mt5.shutdown()
                self.is_connected = False
                self.connection_count = 0
                self.connection_params = None
                logger.info("MT5è¿æ¥å·²æ–­å¼€")
                return True
            except Exception as e:
                logger.error(f"æ–­å¼€MT5è¿æ¥å¼‚å¸¸: {str(e)}")
                return False
    
    def get_connection_info(self) -> Dict[str, Any]:
        """è·å–è¿æ¥ä¿¡æ¯"""
        return {
            'is_connected': self.is_connected,
            'connection_count': self.connection_count,
            'connection_params': self.connection_params
        }

# å…¨å±€è¿æ¥ç®¡ç†å™¨å®ä¾‹
connection_manager = MT5ConnectionManager()
"""
é€šçŸ¥æœåŠ¡æ¨¡å— - å¢å¼ºå¼‚å¸¸å¤„ç†ç‰ˆæœ¬
å®ç°æ¶ˆæ¯æ¨é€å’Œè­¦æŠ¥åŠŸèƒ½
"""
import requests
from typing import Dict, Optional, List, Any
from datetime import datetime
import smtplib
from email.mime.text import MIMEText
import json

from interfaces import INotificationService
from logger import logger, log_execution_time
from exceptions.exception_handler import handle_exceptions

class NotificationService(INotificationService):
    """é€šçŸ¥æœåŠ¡å®ç° - å¢å¼ºå¼‚å¸¸å¤„ç†"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.telegram_token = config.get('telegram_token')
        self.telegram_chat_id = config.get('telegram_chat_id')
        self.email_config = config.get('email', {})
        self.message_queue: List[Dict] = []
        self.max_queue_size = 100
        
        # ç»Ÿè®¡ä¿¡æ¯
        self.stats = {
            'messages_sent': 0,
            'telegram_success': 0,
            'telegram_failures': 0,
            'email_success': 0,
            'email_failures': 0,
            'last_error': None
        }
    
    @handle_exceptions(default_return=False, log_level="ERROR")
    @log_execution_time
    def send_message(self, message: str, level: str = "info") -> bool:
        """å‘é€æ¶ˆæ¯"""
        try:
            self.stats['messages_sent'] += 1
            
            # æ ¹æ®æ¶ˆæ¯çº§åˆ«å†³å®šå‘é€æ–¹å¼
            success = False
            if level == "error":
                telegram_success = self._send_telegram(message)
                email_success = self._send_email(f"é”™è¯¯è­¦æŠ¥: {message}", message)
                success = telegram_success or email_success
            elif level == "warning":
                success = self._send_telegram(message)
            else:
                # infoçº§åˆ«æ¶ˆæ¯åªè®°å½•æ—¥å¿—
                logger.info(message)
                success = True
            
            # è®°å½•æ¶ˆæ¯åˆ°é˜Ÿåˆ—
            self._add_to_queue({
                'timestamp': datetime.now(),
                'level': level,
                'message': message,
                'success': success
            })
            
            return success
            
        except Exception as e:
            self.stats['last_error'] = str(e)
            logger.error(
                f"å‘é€æ¶ˆæ¯å¼‚å¸¸: {str(e)}",
                extra_data={'message': message, 'level': level}
            )
            return False
    
    @handle_exceptions(default_return=False, log_level="ERROR")
    @log_execution_time
    def send_trade_alert(self, trade_details: Dict[str, Any]) -> bool:
        """å‘é€äº¤æ˜“è­¦æŠ¥"""
        try:
            # æ ¼å¼åŒ–äº¤æ˜“ä¿¡æ¯
            message = self._format_trade_message(trade_details)
            
            # å‘é€åˆ°æ‰€æœ‰å¯ç”¨æ¸ é“
            telegram_success = self._send_telegram(message)
            email_success = self._send_email("äº¤æ˜“è­¦æŠ¥", message)
            
            success = telegram_success or email_success
            
            # è®°å½•åˆ°é˜Ÿåˆ—
            self._add_to_queue({
                'timestamp': datetime.now(),
                'level': 'trade',
                'message': message,
                'details': trade_details,
                'success': success
            })
            
            return success
            
        except Exception as e:
            self.stats['last_error'] = str(e)
            logger.error(
                f"å‘é€äº¤æ˜“è­¦æŠ¥å¼‚å¸¸: {str(e)}",
                extra_data={'trade_details': trade_details}
            )
            return False
    
    @handle_exceptions(default_return=False, log_level="ERROR")
    @log_execution_time
    def send_error_alert(self, error_message: str, context: Optional[Dict[str, Any]] = None) -> bool:
        """å‘é€é”™è¯¯è­¦æŠ¥"""
        try:
            # æ ¼å¼åŒ–é”™è¯¯ä¿¡æ¯
            message = f"ğŸš¨ ç³»ç»Ÿé”™è¯¯: {error_message}"
            
            if context:
                message += f"\nä¸Šä¸‹æ–‡: {json.dumps(context, ensure_ascii=False)}"
            
            # å‘é€åˆ°æ‰€æœ‰å¯ç”¨æ¸ é“
            telegram_success = self._send_telegram(message)
            email_success = self._send_email("ç³»ç»Ÿé”™è¯¯è­¦æŠ¥", message)
            
            success = telegram_success or email_success
            
            # è®°å½•åˆ°é˜Ÿåˆ—
            self._add_to_queue({
                'timestamp': datetime.now(),
                'level': 'error',
                'message': message,
                'context': context,
                'success': success
            })
            
            return success
            
        except Exception as e:
            self.stats['last_error'] = str(e)
            logger.error(
                f"å‘é€é”™è¯¯è­¦æŠ¥å¼‚å¸¸: {str(e)}",
                extra_data={'error_message': error_message, 'context': context}
            )
            return False
    
    @handle_exceptions(default_return=False, log_level="WARNING")
    def _send_telegram(self, message: str) -> bool:
        """å‘é€Telegramæ¶ˆæ¯"""
        if not self.telegram_token or not self.telegram_chat_id:
            logger.debug("Telegramé…ç½®æœªè®¾ç½®ï¼Œè·³è¿‡å‘é€")
            return False
        
        try:
            url = f"https://api.telegram.org/bot{self.telegram_token}/sendMessage"
            payload = {
                'chat_id': self.telegram_chat_id,
                'text': message,
                'parse_mode': 'HTML'
            }
            
            response = requests.post(url, json=payload, timeout=10)
            
            if response.status_code == 200:
                self.stats['telegram_success'] += 1
                logger.debug("Telegramæ¶ˆæ¯å‘é€æˆåŠŸ")
                return True
            else:
                self.stats['telegram_failures'] += 1
                logger.warning(
                    f"Telegramæ¶ˆæ¯å‘é€å¤±è´¥: {response.status_code}",
                    extra_data={'status_code': response.status_code}
                )
                return False
                
        except Exception as e:
            self.stats['telegram_failures'] += 1
            self.stats['last_error'] = str(e)
            logger.error(
                f"å‘é€Telegramæ¶ˆæ¯å¼‚å¸¸: {str(e)}",
                extra_data={'message_length': len(message)}
            )
            return False
    
    @handle_exceptions(default_return=False, log_level="WARNING")
    def _send_email(self, subject: str, message: str) -> bool:
        """å‘é€é‚®ä»¶"""
        email_config = self.email_config
        if not email_config.get('enabled', False):
            logger.debug("é‚®ä»¶é…ç½®æœªå¯ç”¨ï¼Œè·³è¿‡å‘é€")
            return False
        
        try:
            smtp_server = email_config.get('smtp_server')
            smtp_port = email_config.get('smtp_port', 587)
            username = email_config.get('username')
            password = email_config.get('password')
            to_address = email_config.get('to_address')
            
            if not all([smtp_server, username, password, to_address]):
                logger.warning("é‚®ä»¶é…ç½®ä¸å®Œæ•´")
                return False
            
            # åˆ›å»ºé‚®ä»¶å†…å®¹
            msg = MIMEText(message, 'plain', 'utf-8')
            msg['Subject'] = subject
            msg['From'] = username
            msg['To'] = to_address
            
            # è¿æ¥SMTPæœåŠ¡å™¨å¹¶å‘é€
            with smtplib.SMTP(smtp_server, smtp_port) as server:
                server.starttls()
                server.login(username, password)
                server.send_message(msg)
            
            self.stats['email_success'] += 1
            logger.debug("é‚®ä»¶å‘é€æˆåŠŸ")
            return True
            
        except Exception as e:
            self.stats['email_failures'] += 1
            self.stats['last_error'] = str(e)
            logger.error(
                f"å‘é€é‚®ä»¶å¼‚å¸¸: {str(e)}",
                extra_data={'subject': subject, 'message_length': len(message)}
            )
            return False
    
    def _format_trade_message(self, trade_details: Dict[str, Any]) -> str:
        """æ ¼å¼åŒ–äº¤æ˜“æ¶ˆæ¯"""
        symbol = trade_details.get('symbol', 'XAUUSD')
        direction = trade_details.get('direction', '')
        volume = trade_details.get('volume', 0)
        entry_price = trade_details.get('entry_price', 0)
        stop_loss = trade_details.get('stop_loss', 0)
        take_profit = trade_details.get('take_profit', 0)
        confidence = trade_details.get('confidence', 0)
        
        # è®¡ç®—é£é™©å›æŠ¥æ¯”
        if direction == 'buy' and entry_price > 0 and stop_loss > 0:
            risk = entry_price - stop_loss
            reward = take_profit - entry_price
            risk_reward = reward / risk if risk > 0 else 0
        elif direction == 'sell' and entry_price > 0 and stop_loss > 0:
            risk = stop_loss - entry_price
            reward = entry_price - take_profit
            risk_reward = reward / risk if risk > 0 else 0
        else:
            risk_reward = 0
        
        # åˆ›å»ºæ ¼å¼åŒ–æ¶ˆæ¯
        emoji = "ğŸŸ¢" if direction == 'buy' else "ğŸ”´"
        message = f"{emoji} äº¤æ˜“ä¿¡å·\n\n"
        message += f"å“ç§: {symbol}\n"
        message += f"æ–¹å‘: {'ä¹°å…¥' if direction == 'buy' else 'å–å‡º'}\n"
        message += f"æ‰‹æ•°: {volume:.2f}\n"
        message += f"å…¥åœº: {entry_price:.2f}\n"
        message += f"æ­¢æŸ: {stop_loss:.2f}\n"
        message += f"æ­¢ç›ˆ: {take_profit:.2f}\n"
        message += f"é£æŠ¥æ¯”: 1:{risk_reward:.2f}\n"
        message += f"å¯ä¿¡åº¦: {confidence:.1f}%\n"
        message += f"æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        
        return message
    
    def _add_to_queue(self, message_info: Dict[str, Any]):
        """æ·»åŠ æ¶ˆæ¯åˆ°é˜Ÿåˆ—"""
        self.message_queue.append(message_info)
        
        # é™åˆ¶é˜Ÿåˆ—å¤§å°
        if len(self.message_queue) > self.max_queue_size:
            self.message_queue = self.message_queue[-self.max_queue_size:]
    
    @handle_exceptions(default_return=[], log_level="ERROR")
    def get_message_history(self, limit: int = 20) -> List[Dict[str, Any]]:
        """è·å–æ¶ˆæ¯å†å²"""
        return self.message_queue[-limit:] if self.message_queue else []
    
    def clear_message_queue(self):
        """æ¸…ç©ºæ¶ˆæ¯é˜Ÿåˆ—"""
        self.message_queue.clear()
    
    @handle_exceptions(default_return={}, log_level="ERROR")
    def get_notification_stats(self) -> Dict[str, Any]:
        """è·å–é€šçŸ¥ç»Ÿè®¡ä¿¡æ¯"""
        stats = self.stats.copy()
        stats['queue_size'] = len(self.message_queue)
        stats['current_time'] = datetime.now().isoformat()
        
        logger.debug(
            "è·å–é€šçŸ¥ç»Ÿè®¡ä¿¡æ¯",
            extra_data={'notification_stats': stats}
        )
        
        return stats
"""
é£é™©ç®¡ç†æ¨¡å— - å¢å¼ºå¼‚å¸¸å¤„ç†ç‰ˆæœ¬
"""
import numpy as np
from typing import Dict, List, Optional, Tuple, Any
from datetime import datetime, timedelta
import threading
from functools import lru_cache

from interfaces import IRiskManager
from logger import logger, log_execution_time
from exceptions.exception_handler import handle_exceptions, handle_specific_exceptions
from exceptions.trading_exceptions import RiskManagementException, RiskValidationException, ValidationException

class EnhancedRiskManager(IRiskManager):
    """å¢å¼ºé£é™©ç®¡ç†å™¨ - å¢å¼ºå¼‚å¸¸å¤„ç†"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.daily_risk_used = 0.0
        self.trade_history: List[Dict] = []
        self.max_history_size = 100
        self.daily_trade_count = 0
        self.max_daily_trades = config.get('max_daily_trades', 10)
        
        # é£é™©æš´éœ²è·Ÿè¸ª
        self.risk_exposure = {
            'total_risk': 0.0,
            'symbol_risk': {},
            'direction_risk': {'long': 0.0, 'short': 0.0}
        }
        
        # ç»Ÿè®¡ä¿¡æ¯
        self.stats = {
            'position_calculations': 0,
            'trade_validations': 0,
            'validation_failures': 0,
            'last_error': None
        }
    
    @handle_exceptions(default_return=0.0)
    @log_execution_time
    def calculate_position_size(self, signal: Dict[str, Any], account_info: Dict[str, Any]) -> float:
        """è®¡ç®—ä»“ä½å¤§å°"""
        try:
            self.stats['position_calculations'] += 1
            
            # æ£€æŸ¥ä¿¡å·æœ‰æ•ˆæ€§
            if signal['signal_type'] == 'neutral':
                logger.debug("ä¸­æ€§ä¿¡å·ï¼Œä»“ä½å¤§å°ä¸º0")
                return 0.0
            
            # è·å–è´¦æˆ·ä½™é¢
            balance = account_info.get('balance', 0)
            if balance <= 0:
                logger.warning("è´¦æˆ·ä½™é¢ä¸ºé›¶æˆ–è´Ÿå€¼")
                return 0.0
            
            # è®¡ç®—å•ç¬”äº¤æ˜“é£é™©é‡‘é¢
            risk_amount = balance * self.config['per_trade_risk']
            
            # è®¡ç®—æ¯ç‚¹ä»·å€¼
            point_value = self._get_point_value(signal.get('symbol', 'XAUUSD'))
            
            # è®¡ç®—æ­¢æŸç‚¹æ•°
            stop_loss_points = self._calculate_stop_loss_points(
                signal['entry_price'], 
                signal['stop_loss'], 
                signal['direction']
            )
            
            # è®¡ç®—ä»“ä½å¤§å°
            if stop_loss_points > 0 and point_value > 0:
                position_size = risk_amount / (stop_loss_points * point_value)
            else:
                logger.warning("æ­¢æŸç‚¹æ•°æˆ–ç‚¹å€¼è®¡ç®—é”™è¯¯")
                return 0.0
            
            # åº”ç”¨ä»“ä½é™åˆ¶
            position_size = self._apply_position_limits(position_size, account_info)
            
            # åº”ç”¨æ–°é—»æ—¶æ®µè°ƒæ•´
            position_size = self._apply_news_period_adjustment(position_size)
            
            # åº”ç”¨å¯ä¿¡åº¦è°ƒæ•´
            position_size = self._apply_confidence_adjustment(position_size, signal.get('confidence', 0))
            
            logger.info(
                f"è®¡ç®—ä»“ä½: {position_size:.4f}æ‰‹",
                extra_data={
                    'symbol': signal.get('symbol'),
                    'position_size': position_size,
                    'risk_amount': risk_amount,
                    'stop_loss_points': stop_loss_points,
                    'point_value': point_value
                }
            )
            
            return position_size
            
        except Exception as e:
            self.stats['last_error'] = str(e)
            logger.error(
                f"è®¡ç®—ä»“ä½å¤§å°å¼‚å¸¸: {str(e)}",
                extra_data={
                    'symbol': signal.get('symbol'),
                    'signal_type': signal.get('signal_type')
                }
            )
            return 0.0
    
    def _get_point_value(self, symbol: str) -> float:
        """è·å–æ¯ç‚¹ä»·å€¼"""
        # è¿™é‡Œåº”è¯¥æ ¹æ®å“ç§ç¡®å®šæ¯ç‚¹ä»·å€¼
        # ç®€åŒ–å¤„ç†ï¼šXAUUSDæ¯ç‚¹ä»·å€¼çº¦ä¸º0.01ç¾å…ƒ/ç‚¹
        if symbol == 'XAUUSD':
            return 0.01
        else:
            return 0.01  # é»˜è®¤å€¼
    
    def _calculate_stop_loss_points(self, entry_price: float, stop_loss: float, direction: str) -> float:
        """è®¡ç®—æ­¢æŸç‚¹æ•°"""
        if direction == 'buy':
            points = (entry_price - stop_loss) / 0.01  # å‡è®¾æ¯ç‚¹0.01
        else:  # sell
            points = (stop_loss - entry_price) / 0.01
        
        return max(1, points)  # è‡³å°‘1ç‚¹
    
    def _apply_position_limits(self, position_size: float, account_info: Dict[str, Any]) -> float:
        """åº”ç”¨ä»“ä½é™åˆ¶"""
        # æœ€å°æ‰‹æ•°é™åˆ¶
        min_lot = self.config.get('min_lot_size', 0.01)
        position_size = max(min_lot, position_size)
        
        # æœ€å¤§æ‰‹æ•°é™åˆ¶
        max_lot = self.config.get('max_lot_size', 0.05)
        position_size = min(max_lot, position_size)
        
        # ä¿è¯é‡‘é™åˆ¶
        free_margin = account_info.get('free_margin', 0)
        if free_margin > 0:
            # ç®€åŒ–è®¡ç®—ï¼šå‡è®¾æ¯æ‰‹éœ€è¦1000ç¾å…ƒä¿è¯é‡‘
            margin_per_lot = 1000
            max_by_margin = free_margin / margin_per_lot
            position_size = min(position_size, max_by_margin)
        
        return round(position_size, 2)  # å››èˆäº”å…¥åˆ°0.01æ‰‹
    
    def _apply_news_period_adjustment(self, position_size: float) -> float:
        """åº”ç”¨æ–°é—»æ—¶æ®µè°ƒæ•´"""
        if self._is_news_period():
            logger.info("æ–°é—»å‘å¸ƒæ—¶æ®µï¼Œä»“ä½å‡åŠ")
            return position_size * 0.5
        return position_size
    
    def _is_news_period(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¤„äºæ–°é—»å‘å¸ƒæ—¶æ®µ"""
        now = datetime.now()
        hour = now.hour
        
        # é‡è¦æ–°é—»å‘å¸ƒæ—¶æ®µï¼ˆUTCæ—¶é—´ï¼‰
        # å‡è®¾é‡è¦æ–°é—»åœ¨13:00-15:00å’Œ19:00-21:00å‘å¸ƒ
        if (13 <= hour < 15) or (19 <= hour < 21):
            return True
        return False
    
    def _apply_confidence_adjustment(self, position_size: float, confidence: float) -> float:
        """åº”ç”¨å¯ä¿¡åº¦è°ƒæ•´"""
        if confidence >= 80:  # é«˜å¯ä¿¡åº¦
            return position_size
        elif confidence >= 60:  # ä¸­ç­‰å¯ä¿¡åº¦
            return position_size * 0.7
        else:  # ä½å¯ä¿¡åº¦
            return position_size * 0.3
    
    @handle_exceptions(default_return=False)
    @log_execution_time
    def validate_trade(self, signal: Dict[str, Any], account_info: Dict[str, Any]) -> bool:
        """éªŒè¯äº¤æ˜“æ˜¯å¦ç¬¦åˆé£æ§è§„åˆ™"""
        try:
            self.stats['trade_validations'] += 1
            
            # æ£€æŸ¥ä¿¡å·ç±»å‹
            if signal['signal_type'] == 'neutral':
                return False
            
            # æ£€æŸ¥æ¯æ—¥é£é™©é™åˆ¶
            if not self._check_daily_risk_limit():
                logger.warning("è¾¾åˆ°æ¯æ—¥é£é™©é™åˆ¶")
                return False
            
            # æ£€æŸ¥å•ç¬”äº¤æ˜“é£é™©
            if not self._check_per_trade_risk(signal, account_info):
                logger.warning("å•ç¬”äº¤æ˜“é£é™©è¶…æ ‡")
                return False
            
            # æ£€æŸ¥æœ€å¤§å›æ’¤
            if not self._check_max_drawdown(account_info):
                logger.warning("è¾¾åˆ°æœ€å¤§å›æ’¤é™åˆ¶")
                return False
            
            # æ£€æŸ¥æŒä»“æ•°é‡
            if not self._check_position_count():
                logger.warning("è¾¾åˆ°æœ€å¤§æŒä»“é™åˆ¶")
                return False
            
            # æ£€æŸ¥æ¯æ—¥äº¤æ˜“æ¬¡æ•°
            if not self._check_daily_trade_count():
                logger.warning("è¾¾åˆ°æ¯æ—¥äº¤æ˜“æ¬¡æ•°é™åˆ¶")
                return False
            
            # æ£€æŸ¥å¸‚åœºæ³¢åŠ¨æ€§
            if not self._check_market_volatility(signal):
                logger.warning("å¸‚åœºæ³¢åŠ¨æ€§è¿‡é«˜")
                return False
            
            logger.debug(
                "äº¤æ˜“éªŒè¯é€šè¿‡",
                extra_data={
                    'symbol': signal.get('symbol'),
                    'signal_type': signal.get('signal_type')
                }
            )
            
            return True
            
        except Exception as e:
            self.stats['validation_failures'] += 1
            self.stats['last_error'] = str(e)
            logger.error(
                f"éªŒè¯äº¤æ˜“å¼‚å¸¸: {str(e)}",
                extra_data={
                    'symbol': signal.get('symbol'),
                    'signal_type': signal.get('signal_type')
                }
            )
            return False
    
    def _check_daily_risk_limit(self) -> bool:
        """æ£€æŸ¥æ¯æ—¥é£é™©é™åˆ¶"""
        daily_risk_limit = self.config.get('max_daily_risk', 0.03)
        return self.daily_risk_used < daily_risk_limit
    
    def _check_per_trade_risk(self, signal: Dict[str, Any], account_info: Dict[str, Any]) -> bool:
        """æ£€æŸ¥å•ç¬”äº¤æ˜“é£é™©"""
        balance = account_info.get('balance', 0)
        if balance <= 0:
            return False
        
        # è®¡ç®—é¢„ä¼°é£é™©
        position_size = self.calculate_position_size(signal, account_info)
        stop_loss_points = self._calculate_stop_loss_points(
            signal['entry_price'], 
            signal['stop_loss'], 
            signal['direction']
        )
        point_value = self._get_point_value(signal.get('symbol', 'XAUUSD'))
        
        estimated_risk = position_size * stop_loss_points * point_value
        risk_percent = estimated_risk / balance
        
        per_trade_risk_limit = self.config.get('per_trade_risk', 0.01)
        
        return risk_percent <= per_trade_risk_limit
    
    def _check_max_drawdown(self, account_info: Dict[str, Any]) -> bool:
        """æ£€æŸ¥æœ€å¤§å›æ’¤"""
        equity = account_info.get('equity', 0)
        balance = account_info.get('balance', 0)
        
        if balance <= 0:
            return False
        
        drawdown = (balance - equity) / balance
        max_drawdown = self.config.get('max_drawdown', 0.05)
        
        return drawdown <= max_drawdown
    
    def _check_position_count(self) -> bool:
        """æ£€æŸ¥æŒä»“æ•°é‡"""
        # è¿™é‡Œåº”è¯¥ä»ç»çºªå•†è·å–å®é™…æŒä»“æ•°é‡
        # ç®€åŒ–å¤„ç†ï¼šå‡è®¾æ²¡æœ‰æŒä»“
        current_positions = 0  # ä»ç»çºªå•†è·å–å®é™…å€¼
        max_positions = self.config.get('max_positions', 1)
        
        return current_positions < max_positions
    
    def _check_daily_trade_count(self) -> bool:
        """æ£€æŸ¥æ¯æ—¥äº¤æ˜“æ¬¡æ•°"""
        # æ£€æŸ¥æ˜¯å¦æ˜¯æ–°çš„ä¸€å¤©
        if not self.trade_history:
            self.daily_trade_count = 0
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯æ–°çš„ä¸€å¤©ï¼ˆç®€åŒ–å¤„ç†ï¼‰
        if datetime.now().hour == 0 and datetime.now().minute < 5:
            self.daily_trade_count = 0
        
        return self.daily_trade_count < self.max_daily_trades
    
    def _check_market_volatility(self, signal: Dict[str, Any]) -> bool:
        """æ£€æŸ¥å¸‚åœºæ³¢åŠ¨æ€§"""
        # è¿™é‡Œåº”è¯¥å®ç°å…·ä½“çš„æ³¢åŠ¨æ€§æ£€æŸ¥é€»è¾‘
        # ç®€åŒ–å¤„ç†ï¼šæ€»æ˜¯è¿”å›True
        return True
    
    @handle_exceptions(default_return=None)
    def update_risk_exposure(self, trade_result: Dict[str, Any]):
        """æ›´æ–°é£é™©æš´éœ²"""
        try:
            # è·å–äº¤æ˜“æ–¹å‘
            direction = trade_result.get('direction', '')
            symbol = trade_result.get('symbol', '')
            volume = trade_result.get('volume', 0)
            
            if not direction or not symbol or volume <= 0:
                logger.warning("æ— æ³•æ›´æ–°é£é™©æš´éœ²: æ— æ•ˆçš„äº¤æ˜“ç»“æœ")
                return
            
            # è®¡ç®—é£é™©æš´éœ²
            if direction == 'buy':
                self.risk_exposure['direction_risk']['long'] += volume
            elif direction == 'sell':
                self.risk_exposure['direction_risk']['short'] += volume
            
            # æ›´æ–°å“ç§é£é™©
            if symbol not in self.risk_exposure['symbol_risk']:
                self.risk_exposure['symbol_risk'][symbol] = 0
            self.risk_exposure['symbol_risk'][symbol] += volume
            
            # æ›´æ–°æ€»é£é™©
            self.risk_exposure['total_risk'] += volume
            
            logger.info(
                f"é£é™©æš´éœ²æ›´æ–°: {symbol} {direction}",
                extra_data={
                    'symbol': symbol,
                    'direction': direction,
                    'volume': volume,
                    'risk_exposure': self.risk_exposure
                }
            )
            
        except Exception as e:
            logger.error(
                f"æ›´æ–°é£é™©æš´éœ²å¼‚å¸¸: {str(e)}",
                extra_data={'trade_result': trade_result}
            )
    
    @handle_exceptions(default_return={})
    def get_risk_stats(self) -> Dict[str, Any]:
        """è·å–é£é™©ç»Ÿè®¡ä¿¡æ¯"""
        stats = self.stats.copy()
        stats['risk_exposure'] = self.risk_exposure
        stats['daily_risk_used'] = self.daily_risk_used
        stats['daily_trade_count'] = self.daily_trade_count
        stats['trade_history_size'] = len(self.trade_history)
        stats['current_time'] = datetime.now().isoformat()
        
        logger.debug(
            "è·å–é£é™©ç»Ÿè®¡ä¿¡æ¯",
            extra_data={'stats': stats}
        )
        
        return stats
# å®‰å…¨é…ç½®è®¾ç½®æŒ‡å—

## ç¬¬ä¸€æ­¥ï¼šå®‰è£…ä¾èµ–

```bash
pip install python-dotenv
# test_basic.py
from config import TradingConfig

def test_config():
    """æµ‹è¯•é…ç½®åŠ è½½"""
    try:
        config = TradingConfig.from_yaml('config/production.yaml')
        print("âœ… é…ç½®åŠ è½½æˆåŠŸï¼")
        print(f"æœ€å¤§é£é™©: {config.max_daily_risk}")
        return True
    except Exception as e:
        print(f"âŒ é…ç½®åŠ è½½å¤±è´¥: {e}")
        return False

if __name__ == "__main__":
    test_config()
"""
å®Œå…¨ä¿®å¤çš„æµ‹è¯•
"""
import sys
import os
sys.path.append(os.path.dirname(__file__))

def test_basic_data_flow():
    """æµ‹è¯•åŸºæœ¬æ•°æ®æµ"""
    print("ğŸ”„ æµ‹è¯•åŸºæœ¬æ•°æ®æµ...")
    
    try:
        from data_manager import DataManager
        
        config = {
            'symbols': ['XAUUSD'],
            'timeframes': ['15m', '1h'],
            'test_mode': True,
            'use_mt5': False
        }
        
        dm = DataManager(config)
        
        # æµ‹è¯•åŸºæœ¬æ•°æ®è·å–
        data = dm.get_market_data('XAUUSD', '15m', 10)
        if not data.empty and len(data) > 0:
            print(f"âœ… åŸºæœ¬æ•°æ®è·å–æˆåŠŸ: {len(data)} æ¡è®°å½•")
            print(f"   ä»·æ ¼èŒƒå›´: {data['low'].min():.2f} - {data['high'].max():.2f}")
        else:
            print("âŒ åŸºæœ¬æ•°æ®è·å–å¤±è´¥")
            return False
        
        # æµ‹è¯•æŠ€æœ¯æŒ‡æ ‡
        indicators = dm.calculate_technical_indicators('XAUUSD', '15m')
        if indicators:
            print(f"âœ… æŠ€æœ¯æŒ‡æ ‡è®¡ç®—æˆåŠŸ: {len(indicators)} ä¸ªæŒ‡æ ‡")
        else:
            print("âŒ æŠ€æœ¯æŒ‡æ ‡è®¡ç®—å¤±è´¥")
            return False
        
        dm.disconnect()
        return True
        
    except Exception as e:
        print(f"âŒ åŸºæœ¬æ•°æ®æµæµ‹è¯•å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()
        return False

def test_error_handling_improved():
    """æµ‹è¯•æ”¹è¿›çš„é”™è¯¯å¤„ç†"""
    print("\nğŸ›¡ï¸ æµ‹è¯•æ”¹è¿›çš„é”™è¯¯å¤„ç†...")
    
    try:
        from data_manager import DataManager
        
        config = {
            'symbols': ['XAUUSD'],
            'timeframes': ['15m'],
            'test_mode': True,
            'use_mt5': False
        }
        
        dm = DataManager(config)
        
        # æµ‹è¯•æ— æ•ˆå“ç§
        invalid_symbol_data = dm.get_market_data('INVALID', '15m', 5)
        if invalid_symbol_data.empty:
            print("âœ… æ— æ•ˆå“ç§å¤„ç†æ­£å¸¸")
        else:
            print("âŒ æ— æ•ˆå“ç§å¤„ç†å¼‚å¸¸")
            return False
        
        # æµ‹è¯•æ— æ•ˆæ—¶é—´æ¡†æ¶
        invalid_tf_data = dm.get_market_data('XAUUSD', '5m', 5)
        if invalid_tf_data.empty:
            print("âœ… æ— æ•ˆæ—¶é—´æ¡†æ¶å¤„ç†æ­£å¸¸")
        else:
            print("âŒ æ— æ•ˆæ—¶é—´æ¡†æ¶å¤„ç†å¼‚å¸¸")
            return False
        
        # æµ‹è¯•è¾¹ç•Œæ•°é‡
        zero_data = dm.get_market_data('XAUUSD', '15m', 0)
        if zero_data.empty:
            print("âœ… é›¶æ•°é‡å¤„ç†æ­£å¸¸")
        else:
            print("âŒ é›¶æ•°é‡å¤„ç†å¼‚å¸¸")
            return False
        
        dm.disconnect()
        return True
        
    except Exception as e:
        print(f"âŒ é”™è¯¯å¤„ç†æµ‹è¯•å¤±è´¥: {e}")
        return False

def test_performance():
    """æµ‹è¯•æ€§èƒ½"""
    print("\nâš¡ æµ‹è¯•æ€§èƒ½...")
    
    try:
        from data_manager import DataManager
        import time
        
        config = {
            'symbols': ['XAUUSD'],
            'timeframes': ['15m'],
            'test_mode': True,
            'use_mt5': False
        }
        
        dm = DataManager(config)
        
        # æµ‹è¯•æ­£å¸¸æ•°é‡
        start_time = time.time()
        normal_data = dm.get_market_data('XAUUSD', '15m', 100)
        normal_time = time.time() - start_time
        
        if not normal_data.empty:
            print(f"âœ… æ­£å¸¸æ•°é‡æ€§èƒ½: {normal_time:.3f}ç§’, {len(normal_data)}æ¡è®°å½•")
        else:
            print("âŒ æ­£å¸¸æ•°é‡æ€§èƒ½æµ‹è¯•å¤±è´¥")
            return False
        
        # æµ‹è¯•å¤§æ•°é‡ï¼ˆåº”è¯¥è¢«é™åˆ¶ï¼‰
        start_time = time.time()
        large_data = dm.get_market_data('XAUUSD', '15m', 5000)
        large_time = time.time() - start_time
        
        if not large_data.empty and len(large_data) <= 500:
            print(f"âœ… å¤§æ•°é‡é™åˆ¶æ­£å¸¸: {large_time:.3f}ç§’, é™åˆ¶åˆ°{len(large_data)}æ¡è®°å½•")
        else:
            print("âŒ å¤§æ•°é‡é™åˆ¶å¼‚å¸¸")
            return False
        
        dm.disconnect()
        return True
        
    except Exception as e:
        print(f"âŒ æ€§èƒ½æµ‹è¯•å¤±è´¥: {e}")
        return False

def main():
    """ä¸»æµ‹è¯•å‡½æ•°"""
    print("ğŸš€ å¼€å§‹å®Œå…¨ä¿®å¤çš„æµ‹è¯•...\n")
    
    tests = [
        test_basic_data_flow,
        test_error_handling_improved, 
        test_performance
    ]
    
    results = []
    for test in tests:
        try:
            result = test()
            results.append(result)
            print("")  # ç©ºè¡Œåˆ†éš”
        except Exception as e:
            print(f"âŒ æµ‹è¯•å¼‚å¸¸: {e}")
            import traceback
            traceback.print_exc()
            results.append(False)
    
    # æ±‡æ€»ç»“æœ
    print("="*60)
    print("ğŸ“‹ å®Œå…¨ä¿®å¤æµ‹è¯•ç»“æœ:")
    passed = sum(results)
    total = len(results)
    
    print(f"âœ… é€šè¿‡: {passed}/{total}")
    print(f"âŒ å¤±è´¥: {total - passed}/{total}")
    
    if passed == total:
        print("\nğŸ‰ å®Œå…¨ä¿®å¤æµ‹è¯•é€šè¿‡!")
        print("ğŸ’¡ ç³»ç»Ÿç°åœ¨å¯ä»¥æ­£å¸¸è¿è¡Œ!")
        return True
    else:
        print("\nâš ï¸  ä»æœ‰æµ‹è¯•å¤±è´¥ï¼Œä½†æ ¸å¿ƒåŠŸèƒ½å¯èƒ½æ­£å¸¸")
        return passed >= 1  # åªè¦åŸºæœ¬åŠŸèƒ½æ­£å¸¸å°±è¿”å›True

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
